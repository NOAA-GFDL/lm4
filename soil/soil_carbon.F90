module soil_carbon_mod

! Do not use external model stuff if compiling standalone version
#ifndef STANDALONE_SOIL_CARBON

#include "../shared/debug.inc"

use constants_mod, only : pi, dens_h2o
use land_constants_mod, only : Rugas, seconds_per_year
use fms_mod, only: check_nml_error, file_exist, close_file, &
            stdlog, mpp_pe, mpp_root_pe, error_mesg, FATAL, NOTE
use vegn_data_mod, only: K1,K2
use land_numerics_mod,only: tridiag
use land_data_mod, only: log_version
use land_debug_mod, only: get_current_point, is_watch_point, check_var_range

#ifdef INTERNAL_FILE_NML
use mpp_mod, only: input_nml_file
#else
use fms_mod, only: open_namelist_file
#endif
#endif


! End of external model stuff

implicit none

private


! ==== public interfaces =====================================================
public :: soil_pool
public :: soilMaxCohorts

public :: update_pool
public :: add_litter
public :: add_C_N_to_cohorts
public :: add_C_N_to_rhizosphere
public :: combine_pools
public :: poolTotals, poolTotals1
public :: init_soil_pool
public :: read_soil_carbon_namelist

public :: tracer_leaching_with_litter
public :: cull_cohorts
public :: transfer_pool_fraction
public :: retrieve_DOC ! report DOC concentration to hlsp_hydrology
public :: retrieve_DON
public :: retrieve_dissolved_mineral_N
public :: mycorrhizal_mineral_N_uptake_rate
public :: mycorrhizal_decomposition
public :: litterDensity

#ifndef STANDALONE_SOIL_CARBON
public :: A_function
#endif
public :: debug_pool

public :: soil_carbon_option, SOILC_CENTURY, SOILC_CENTURY_BY_LAYER, &
    SOILC_CORPSE, SOILC_CORPSE_N

public :: soil_NO3_deposition!x2z
public :: soil_NH4_deposition!x2z
public :: soil_org_N_deposition
public :: ammonium_solubility, nitrate_solubility

public :: N_C_TYPES, C_FAST, C_SLOW, C_MIC
public :: c_shortname, c_longname
public :: adjust_pool_ncohorts
! =====end of public interfaces ==============================================


! ==== module constants ======================================================
character(len=*), parameter :: module_name = 'soil_carbon_mod'
#include "../shared/version_variable.inc"

integer, parameter :: N_C_TYPES = 3  ! Carbon chemical species (Cellulose, lignin, microbial products)
integer, parameter :: & ! indices of carbon chemical species
    C_FAST = 1, & ! cellulose (fast)
    C_SLOW = 2, & ! lignin (slow)
    C_MIC = 3    ! microbial producs

! names of the carbon types, for i/o
character(len=12), parameter :: c_shortname(N_C_TYPES) = (/'fast        ','slow        ','deadmic     '/)
character(len=12), parameter :: c_longname(N_C_TYPES)  = (/'fast        ','slow        ','dead microbe'/)

! soil carbon options
integer, parameter :: &
    SOILC_CENTURY          = 1, & ! CENTURY-like decomposition
    SOILC_CENTURY_BY_LAYER = 2, & ! CENTURY-like decomposition with rates different in soil layers
    SOILC_CORPSE           = 3, & ! CORPSE model
    SOILC_CORPSE_N         = 4    ! This option enables all nitrogen code

integer, parameter :: init_n_cohorts = 3 ! initial number of cohorts in a litter pool

! For fixed rhizosphere mode: Separate cohorts just for rhizosphere and bulk soil
integer, parameter :: RHIZ=1, BULK=2

! Options for N_limit_scheme
! NLIM_DOWNREGULATE limits decomposition so it stops when N is limiting
! NLIM_OVERFLOW decomposes carbon at potential decomposition rate and sends excess carbon
!   (as determined by N availability) to overflow respiration
integer, parameter :: NLIM_DOWNREGULATE=1, NLIM_OVERFLOW=2

#ifdef STANDALONE_SOIL_CARBON
real,parameter::pi=3.141592
real,parameter::Rugas=8.314472
real,parameter::dens_h2o=1000.
integer,parameter::FATAL=0,NOTE=1
real,parameter :: seconds_per_year=86400.0*365.0
#endif

! ==== types =================================================================

! Individual litter cohort with its own carbon pools
type litterCohort
    ! Carbon pools
    real :: litterC    (N_C_TYPES) = 0.0 ! Carbon substrate. Relative amounts of C species are important for resp rate
    real :: protectedC (N_C_TYPES) = 0.0 ! Aggregate and mineral complex C
    real :: livingMicrobeC = 0.0  ! Current carbon mass of live microbes
    real :: livingMicrobeN = 0.0  ! x2z Current N mass of live microbes
    real::CO2            = 0.0              ! Cumulative CO2 generated by decomposition
    real::Rtot           = 0.0              ! Cumulative decomposition (includes double counting through microbial products)

    real :: litterN    (N_C_TYPES) = 0.0 ! x2z Nitrogen substrate
    real :: protectedN (N_C_TYPES) = 0.0 ! x2z
    real :: IMM_N_max       = 0.0  ! x2z Maximum inorganic N immobilization (what's available in that time step)
    real :: IMM_N_gross     = 0.0  ! x2z Actual gross inorganic N immobilization
    real :: MINER_gross     = 0.0  ! x2z Actual gross inorganic N mineralization
    real :: MINER_prod      = 0.0  ! x2z Actual gross inorganic N mineralization
    real :: IMM_Nprod       = 0.0  ! x2z Actual gross inorganic N mineralization

    real :: originalLitterC = 0.0  ! Keep track for carbon balance check
    real :: originalLitterN = 0.0  ! Keep track for N balance check
end type litterCohort


! Pool type, can hold multiple individual litter/carbon cohorts
type soil_pool
    integer::max_cohorts    ! Maximum number of cohorts, allows different pools to have different maximum heterogeneity
    integer::n_cohorts = 0  ! actual number of cohorts in the pool
    real::protection_rate   ! Pool-specific rate that carbon is transferred to protected pool (aggregate and chemical protection)
    real::Qmax              ! Pool DOC sorption capacity (See Mayes et al 2012)
    type(litterCohort),allocatable::litterCohorts(:)
    real :: dissolved_carbon  (N_C_TYPES) = 0.0
    real :: dissolved_nitrogen(N_C_TYPES) = 0.0

    real :: protection_rate_N = 0.0
    real :: ammonium = 0.0, nitrate  = 0.0
    real :: nitrif   = 0.0, denitrif = 0.0

    ! bookkeeping variables for soil carbon acceleration
    real, dimension(N_C_TYPES) :: &
       C_in           = 0.0, N_in           = 0.0, & ! accumulated inputs
       protected_C_in = 0.0, protected_N_in = 0.0, & ! accumulated protected inputs
       C_turnover     = 0.0, N_turnover     = 0.0, & ! accumulated turnovers
       protected_C_turnover = 0.0, protected_N_turnover = 0.0 ! accumulated turnovers of protected C and N
end type soil_pool

!==== module variables =======================================================

!---- namelist ---------------------------------------------------------------
character(32) :: soil_carbon_model_to_use = 'CENTURY-like' ! or 'CENTURY-like-by-layer', or 'CORPSE', or 'CORPSE-N'
logical                   :: use_rhizosphere_cohort=.FALSE.  ! Use 2 fixed cohorts for rhizosphere and bulk soil if true
logical                   :: denitrif_first_order=.FALSE.   ! Do first-order denitrification from nitrate pool (not as part of OM decomp) if true
real,dimension(N_C_TYPES) :: Ea=(/37e3,54e3,50e3/)          ! Activation energy (kJ/mol)
real :: Ea_NH4=37e3                    ! Activation energy for immobilization of ammonium (kJ/mol)
real :: Ea_NO3=37e3                    ! Activation energy for immobilization of nitrate (kJ/mol)
real :: Ea_nitrif=37e3                 ! Activation energy for nitrification of ammonium  (kJ/mol)
real :: Ea_denitr=37e3                 ! Activation energy for uptake of inorganic nitrogen  (kJ/mol)
real :: Vmax_myc_min_N_uptk=365.0      ! Vmax of mycorrhizal uptake of mineral N (year-1)
real :: k_myc_min_N_uptk=0.01          ! half-saturation constant for mycorrhizal uptake of mineral N (kgC/m3 of mycorrhizal biomass)
real :: k_myc_decomp=0.01              ! half-saturation constant for mycorrhizal decomposition
real :: k_conc_myc_min_N_uptk=3e-3     ! half-saturation constant for mycorrhizal uptake of mineral N (kgN/m3 of NO3 or NH4)
real,dimension(N_C_TYPES) :: vmaxref_myc_decomp=(/4500e0,25e0,600e0/)
real,dimension(N_C_TYPES) :: vmaxref=(/4e1,1e1,.5e1/)       ! Vmax at reference temperature (yr-1)
real,dimension(N_C_TYPES) :: kC=(/.5,.1,0.05/)              ! Michaelis-Menton C parameter (dimensionless)
real :: Tmic=0.2                       ! Microbial mean lifetime (yr)
real :: et=0.5                         ! Fraction of microbial turnover not converted to CO2
real :: V_NH4_ref=0.03                 ! Ref. Microbes Efficiency of Ammonium immobilizatiion (yr-1 (kg-microbial-C-biomass/m2)-1) uptake rate per unit microbe C-biomass
real :: V_NO3_ref=0.01                 ! Ref. Microbes Efficiency of Nitrate immobilizatiion
real :: Knitr_ref=0.01                 ! Nitirification constant at reference temperature  (yr-1)
real :: Kdenitr_ref=0.01               ! Denitirification constant at reference temperature  (yr-1)
real, dimension(N_C_TYPES) :: vmaxref_denitrif=(/450e0,2.5e0,60e0/) ! Organic matter decomp rates with denitrification as electron acceptor
real :: k_denitrif=1e-2                ! Half saturation constant for denitrification (kgNO3-N/kgNO3-N demand/year)
real :: denitrif_NO3_factor=0.18
real :: CN_microb=8                    ! Fixed microbial C:N ratio

real,dimension(N_C_TYPES) :: eup=(/0.6,0.2,0.1/)            ! Fraction of degraded C that goes into microbial biomass
real,dimension(N_C_TYPES) :: eup_myc=(/0.6,0.2,0.1/)        ! Fraction of degraded C that goes into mycorrhizal biomass
real,dimension(N_C_TYPES) :: mup=(/0.9,0.9,0.9/) ! Fraction of decomposed N that goes into microbial biomass
real,dimension(N_C_TYPES) :: mup_myc=(/0.9,0.9,0.9/)

real :: minMicrobeC=1e-5               ! Minimum microbial biomass (prevents complete collapse if > 0.0)
real :: gamma_nitr=0.6                 ! Proportion of ammonium that is NOT lost as gas during the nitrification process

real :: D=3.0                          ! Diffusion coefficient (for carbon and enzyme movement)
real :: enzfrac=1.0                    ! Relative amount of enzymes produced by microbes
real :: tProtected=10.0                ! Turnover rate of protected carbon (yr-1)
real :: tProtected_N=10.0              ! Turnover rate of protected nitrogen (yr-1)
real :: protection_rate=1.0            ! Rate that carbon becomes protected (yr-1 kg-microbial-biomass-1)
real :: protection_rate_N=1.0

real,dimension(N_C_TYPES) :: protection_species=(/0.5,0.5,1.0/)  ! Relative protection rate of each flavor

real,dimension(N_C_TYPES) :: protection_species_N=(/0.5,0.5,1.0/)

real :: C_leaching_solubility=0.5      ! Amount of carbon dissolves in soil water at saturated moisture (fraction)
real :: N_leaching_solubility=0.5      ! Amount of nitrogen dissolves in soil water at saturated moisture (fraction)
real :: ammonium_solubility=0.1        ! Amount of ammonium dissolves in soil water at saturated moisture (fraction)
real :: nitrate_solubility=0.8         ! Amount of nitrate dissolves in soil water at saturated moisture (fraction)

real,dimension(N_C_TYPES) :: C_flavor_relative_solubility=(/1.0,1.0,1.0/) ! For each C flavor, relative to 1.0
real,dimension(N_C_TYPES) :: N_flavor_relative_solubility=(/1.0,1.0,1.0/) ! For each N flavor, relative to 1.0

real :: protected_relative_solubility=1.0 ! Relative to 1.0
real :: N_protected_relative_solubility=1.0 ! Relative to 1.0

real :: DOC_deposition_rate=1.0        ! Amount of dissolved C deposited after leaching (fraction)
real :: DON_deposition_rate=1.0        ! Amount of dissolved N deposited after leaching (fraction)

real :: gas_diffusion_exp=2.5          ! Exponent for gas diffusion power law dependence on theta
                                                            ! See Meslin et al 2010, SSAJ
real :: litterDensity=22.0             ! C density of litter layer (kg/m3)
                                                            ! 22.0 roughly from Gaudinsky et al 2000
real :: min_anaerobic_resp_factor=0.0  ! Minimum for high soil moisture Resp limitation

real :: denitrif_theta_min=0.5         ! Minimum theta for denitrification to occur
integer :: soilMaxCohorts=7            ! Maximum number of cohorts in soil carbon pools

real :: tol=1e-4                       ! Tolerance for cohort carbon check
logical :: microbe_driven_protection=.TRUE. ! Whether to use microbial biomass in protection rate
integer :: N_limit_scheme = NLIM_OVERFLOW  ! N limitation scheme to use: See definitions above

namelist /soil_carbon_nml/ &
    soil_carbon_model_to_use, use_rhizosphere_cohort,&
    Ea,vmaxref,kC,Tmic,et,eup,minMicrobeC,soilMaxCohorts,gas_diffusion_exp,&
    tol,enzfrac,tProtected,protection_rate,protection_species,C_leaching_solubility,C_flavor_relative_solubility,DOC_deposition_rate,&
    litterDensity,protected_relative_solubility,min_anaerobic_resp_factor,microbe_driven_protection,&
    Ea_NH4,Ea_NO3,Ea_nitrif,Ea_denitr,denitrif_theta_min,&
    V_NH4_ref,V_NO3_ref,Knitr_ref,Kdenitr_ref,&
    CN_microb,mup,gamma_nitr,tProtected_N,&
    protection_rate_N,&
    protection_species_N,&
    N_leaching_solubility,&
    N_flavor_relative_solubility,&
    N_protected_relative_solubility,&
    DON_deposition_rate,&
    N_limit_scheme,&
    Vmax_myc_min_N_uptk,k_myc_min_N_uptk,eup_myc,mup_myc,vmaxref_myc_decomp,k_myc_decomp,k_conc_myc_min_N_uptk,&
    vmaxref_denitrif,k_denitrif,denitrif_first_order,denitrif_NO3_factor,nitrate_solubility,ammonium_solubility


!---- end-of-namelist --------------------------------------------------------
integer :: soil_carbon_option = 0    ! flag specifying which soil carbon to use,
        ! one of SOILC_CENTURY, SOILC_CENTURY_BY_LAYER, SOILC_CORPSE, SOILC_CORPSE_N


contains ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


subroutine init_soil_pool(pool,protectionRate,Qmax,max_cohorts)
    type(soil_pool),intent(inout)::pool
    real,optional,intent(in) :: protectionRate,Qmax
    integer,optional,intent(in) :: max_cohorts

    type(litterCohort) :: newCohort

    pool%max_cohorts=soilMaxCohorts
    pool%protection_rate=protection_rate
    pool%Qmax=0.0
    pool%dissolved_carbon=0.0

    IF (present(max_cohorts)) pool%max_cohorts=min(max_cohorts,soilMaxCohorts)
    IF (present(protectionRate)) pool%protection_rate=protectionRate
    IF (present(Qmax)) pool%Qmax=Qmax

    pool%n_cohorts = 0
    IF (allocated(pool%litterCohorts)) deallocate(pool%litterCohorts)

    IF (use_rhizosphere_cohort) THEN
        DO WHILE(pool%n_cohorts<max(BULK,RHIZ))
            call initializeCohort(newCohort)
            call add_cohort(pool,newCohort)
        ENDDO
    ENDIF

end subroutine init_soil_pool

! =============================================================================
#ifndef STANDALONE_SOIL_CARBON
subroutine read_soil_carbon_namelist
  integer :: unit         ! unit for namelist i/o
  integer :: io           ! i/o status for the namelist
  integer :: ierr         ! error code, returned by i/o routines

  call log_version(version, module_name, &
  __FILE__)
#ifdef INTERNAL_FILE_NML
  read (input_nml_file, nml=soil_carbon_nml, iostat=io)
  ierr = check_nml_error(io, 'soil_carbon_nml')
#else
  if (file_exist('input.nml')) then
     unit = open_namelist_file()
     ierr = 1;
     do while (ierr /= 0)
        read (unit, nml=soil_carbon_nml, iostat=io, end=10)
        ierr = check_nml_error (io, 'soil_carbon_nml')
     enddo
10   continue
     call close_file (unit)
  endif
#endif
  if (mpp_pe() == mpp_root_pe()) then
     unit=stdlog()
     write(unit, nml=soil_carbon_nml)
  endif


  ! parse soil carbon option
  select case (soil_carbon_model_to_use)
  case('CENTURY-like')
    soil_carbon_option = SOILC_CENTURY
  case('CENTURY-like-by-layer')
    soil_carbon_option = SOILC_CENTURY_BY_LAYER
  case('CORPSE')
    soil_carbon_option = SOILC_CORPSE
  case('CORPSE-N')
    soil_carbon_option = SOILC_CORPSE_N
  case default
    call error_mesg('read_soil_carbon_namelist', &
        '"'//trim(soil_carbon_model_to_use)//'" is an invalid option for soil_carbon_model_to_use', FATAL)
  end select

end subroutine read_soil_carbon_namelist
#endif


#ifdef STANDALONE_SOIL_CARBON
subroutine read_soil_carbon_namelist(file)
character*(*),optional,intent(in)::file

integer :: namelistunit
namelistunit=12300
! Read parameters from namelist
if(present(file)) then
print *,'Reading soil params from namelist: ',file
OPEN(unit=namelistunit,file=file)
else
OPEN(unit=namelistunit,file='soilparams.nml')
endif
READ(unit=namelistunit,NML=soil_carbon_nml)
CLOSE(unit=namelistunit)

end subroutine
#endif

! Deposit ammonium into soil pool
subroutine soil_NH4_deposition(NH4_dep,pool)
    type(soil_pool),intent(inout) :: pool
    real,intent(in)::NH4_dep

    pool%ammonium=pool%ammonium+NH4_dep
end subroutine

! Deposit nitrate into soil pool
subroutine soil_NO3_deposition(NO3_dep,pool)
    type(soil_pool),intent(inout) :: pool
    real,intent(in)::NO3_dep

    pool%nitrate=pool%nitrate+NO3_dep
end subroutine

! Deposit organic nitrogen into soil pool. Assumes it's all "fast", for now
subroutine soil_org_N_deposition(org_N_dep,pool)
    type(soil_pool),intent(inout) :: pool
    real,intent(in)::org_N_dep

    call add_C_N_to_cohorts(pool,litterN=(/org_N_dep,0.0,0.0/))
end subroutine

subroutine dissolve_carbon(pool,theta)
  type(soil_pool),intent(inout)::pool
  real,intent(in)::theta

  real :: C_dissolution_rate, N_dissolution_rate
  real :: C_protected_solubility, N_protected_solubility
  real::C_dissolved(N_C_TYPES),protectedC_dissolved(N_C_TYPES),livemicrobeC_dissolved
  real::N_dissolved(N_C_TYPES),protectedN_dissolved(N_C_TYPES),livemicrobeN_dissolved

  if (theta <= 0.0) return ! do nothing if water in not positive

  C_dissolution_rate=C_leaching_solubility*theta

  ! Protected carbon can dissolve, but much faster under high moisture conditions
  C_protected_solubility=theta**gas_diffusion_exp*protected_relative_solubility
  if (C_protected_solubility<0.0) C_protected_solubility=0.0
  if (C_protected_solubility>1.0) C_protected_solubility=1.0

  IF(soil_carbon_option == SOILC_CORPSE_N) THEN
      N_dissolution_rate=N_leaching_solubility*theta

      N_protected_solubility=theta**gas_diffusion_exp*N_protected_relative_solubility
      if (N_protected_solubility<0.0) N_protected_solubility=0.0
      if (N_protected_solubility>1.0) N_protected_solubility=1.0
  ELSE
      N_dissolution_rate = 0.0
      N_protected_solubility = 0.0
  ENDIF

  call remove_C_N_fraction_from_pool(pool,C_dissolution_rate,N_dissolution_rate, &
              litterC_removed=C_dissolved,protectedC_removed=protectedC_dissolved,&
              livemicrobeC_removed=livemicrobeC_dissolved,&
              litterN_removed=N_dissolved,protectedN_removed=protectedN_dissolved,&
              livemicrobeN_removed=livemicrobeN_dissolved,&
              C_protectedMobility=C_protected_solubility,livingMicrobeMobility=0.0,&
              C_litterMobility=C_flavor_relative_solubility,N_protectedMobility=N_protected_solubility,&
              N_litterMobility=N_flavor_relative_solubility)

  C_dissolved=C_dissolved+protectedC_dissolved
  ! protected_turnover_rate=protected_turnover_rate+protectedC_dissolved/dt
  N_dissolved=N_dissolved+protectedN_dissolved
  ! protected_N_turnover_rate=protected_N_turnover_rate+protectedN_dissolved/dt

  pool%dissolved_carbon=pool%dissolved_carbon+C_dissolved
  pool%dissolved_nitrogen=pool%dissolved_nitrogen+N_dissolved
end subroutine dissolve_carbon


subroutine deposit_dissolved_C(pool)
  type(soil_pool),intent(inout)::pool
  real::deposited_C(N_C_TYPES),deposited_N(N_C_TYPES)

  call check_var_range(pool%dissolved_carbon,0.0,HUGE(1.0),'deposit_dissolved_C','pool%dissolved_carbon',FATAL)
  call check_var_range(DOC_deposition_rate,0.0,HUGE(1.0),'deposit_dissolved_C','DOC_deposition_rate',FATAL)
  deposited_C(:) = max(0.0, DOC_deposition_rate*pool%dissolved_carbon(:))
  if (is_watch_point()) then
     __DEBUG1__(pool%dissolved_carbon)
     __DEBUG1__(DOC_deposition_rate)
     __DEBUG1__(deposited_C)
  endif
  call check_var_range(deposited_C,0.0,HUGE(1.0),'deposit_dissolved_C','deposited_C',FATAL)

  where(deposited_C > pool%dissolved_carbon)
      deposited_C=pool%dissolved_carbon
      pool%dissolved_carbon=0.0
  elsewhere
      pool%dissolved_carbon=pool%dissolved_carbon-deposited_C
  end where

  IF (soil_carbon_option == SOILC_CORPSE_N) THEN
      deposited_N=DOC_deposition_rate*pool%dissolved_nitrogen
      where(deposited_N > pool%dissolved_nitrogen) ! xz
          deposited_N=pool%dissolved_nitrogen  ! xz  (kg/m2)
          pool%dissolved_nitrogen=0.0! xz
      elsewhere! xz
          pool%dissolved_nitrogen=pool%dissolved_nitrogen-deposited_N   ! xz
      end where! xz
  ELSE
      deposited_N=0.0
  ENDIF

  call check_var_range(deposited_C,0.0,HUGE(1.0),'deposit_dissolved_C','deposited_C',FATAL)
  call add_C_N_to_cohorts(pool,litterC=deposited_C,litterN=deposited_N)
end subroutine deposit_dissolved_C


subroutine update_pool(pool,T,theta,air_filled_porosity,liquid_water,frozen_water,dt,layerThickness,&
            C_loss_rate, N_loss_rate, CO2prod, &
            deadmic_C_produced,deadmic_N_produced,&
            protected_C_produced,protected_N_produced,&
            protected_turnover_rate,protected_N_turnover_rate,&
            nitrification,denitrification,N_mineralization,N_immobilization,&
            badCohort)
    type(soil_pool),intent(inout)::pool
    real,intent(in)::T,theta,dt,air_filled_porosity,liquid_water,frozen_water,layerThickness
    real,intent(out) :: C_loss_rate(N_C_TYPES), N_loss_rate(N_C_TYPES) ! loss rates for C and N per time step
    real,intent(out)::CO2prod,nitrification,denitrification,N_mineralization,N_immobilization !  kgC/m2 and kgN/m2 (not rates)
    real,intent(out)::protected_C_produced(N_C_TYPES),protected_N_produced(N_C_TYPES),&
        protected_turnover_rate(N_C_TYPES),protected_N_turnover_rate(N_C_TYPES),deadmic_C_produced,deadmic_N_produced
    integer,intent(out),optional::badCohort
    ! dt is in years!

    integer::n

    real::tempresp(N_C_TYPES),temp_N_decomposed(N_C_TYPES),temp_protected(N_C_TYPES),temp_N_protected(N_C_TYPES),&
            tempCO2,temp_protected_turnover_rate(N_C_TYPES),temp_protected_N_turnover_rate(N_C_TYPES),&
            Prate_limited(N_C_TYPES),Prate_limited_N(N_C_TYPES),prevC(N_C_TYPES),prevN(N_C_TYPES),&
            temp_deadmic_C,temp_deadmic_N,tempIMM_N,soil_IMM_N,temp_MINERAL, soil_MINERAL,temp_livemic_C,temp_livemic_N

    real::activeVolume,inactiveVolume,cohortVolume! xz
    real::nitrif,Denitrif! xz

    type(litterCohort) :: total

!   if (is_watch_point()) then
!      write(*,*)'##### update_pool input ####'
!      __DEBUG4__(T,theta,dt,air_filled_porosity)
!      __DEBUG3__(liquid_water,frozen_water,layerThickness)
!      do n=1, pool%n_cohorts
!          write(*,*) 'cohort ',n
!          __DEBUG1__(pool%litterCohorts(n)%litterC)
!          __DEBUG1__(pool%litterCohorts(n)%protectedC)
!           __DEBUG2__(pool%litterCohorts(n)%livingMicrobeC,pool%litterCohorts(n)%originalLitterC)
!           __DEBUG1__(pool%litterCohorts(n)%CO2)
!       enddo
!    endif

    C_loss_rate(:)=0.0
    N_loss_rate(:)=0.0
    CO2prod=0.0
    protected_C_produced=0.0
    protected_turnover_rate=0.0
    nitrif=0.0! xz
    denitrification=0.0
    protected_N_produced=0.0
    protected_N_turnover_rate=0.0
    deadmic_C_produced=0.0
    deadmic_N_produced=0.0
    soil_IMM_N=0.0
    soil_MINERAL=0.0


    if(present(badCohort)) badCohort=0


    if(pool%nitrate<-1e-11 .AND. soil_carbon_option == SOILC_CORPSE_N) THEN
        call error_mesg('update_pool','Nitrate < 0',FATAL)
    endif

    if(.NOT.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    call cull_cohorts(pool)



    ! Protection rate is multiplied by available space, so protected C does not exceed Pmax
    ! However, the rate is not adjusted for each cohort, so it may go slightly above the pool Pmax
    ! ---   Based on conversation with Melanie Mayes, I am changing this so Qmax affects the protected
    ! ---   carbon formation rate rather than the maximum.

    Prate_limited=pool%protection_rate*protection_species*pool%Qmax
    Prate_limited_N=pool%protection_rate_N*protection_species_N*pool%Qmax

    ! Need to convert originalLitterC into a meaningful volume, since it will keep increasing as cohorts are combined
    ! How about this: non-mineralized C keeps volume based on estimated density
    ! Volume of mineralized C is just capped at remaining layer volume, with the assumption that the mineralized portion
    ! of volume for all cohorts just gets intermingled and does not need to sum to layer volume
!    if (is_watch_point()) then
!       write(*,*) '##### update_pool outpt #####'
!    endif


    DO n=1,pool%n_cohorts
        prevC=pool%litterCohorts(n)%litterC
        prevN=pool%litterCohorts(n)%litterN
        activeVolume=cohortCsum(pool%litterCohorts(n),.TRUE.)/litterDensity
        inactiveVolume=min(pool%litterCohorts(n)%originalLitterC/litterDensity,layerThickness)-activeVolume
        cohortVolume=activeVolume+max(0.0,inactiveVolume)
        call update_cohort(cohort=pool%litterCohorts(n),nitrate=pool%nitrate,ammonium=pool%ammonium,cohortVolume=cohortVolume,T=T,theta=max(theta,0.0),&
                        air_filled_porosity=max(air_filled_porosity,0.0),&
                        protection_rate=Prate_limited,protection_rate_N=Prate_limited_N,&
                        dt=dt,&
                        totalResp=tempresp,totalN_decomposed=temp_N_decomposed,deadmic_C_produced=temp_deadmic_C,deadmic_N_produced=temp_deadmic_N,&
                        protected_produced=temp_protected,protected_N_produced=temp_N_protected,&
                        protected_turnover_rate=temp_protected_turnover_rate,protected_N_turnover_rate=temp_protected_N_turnover_rate,&
                        CO2prod=tempCO2,IMM_Nprod=tempIMM_N,MINERAL_prod=temp_MINERAL,denitrif=denitrif,livemic_C_produced=temp_livemic_C,livemic_N_produced=temp_livemic_N)
        IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
            if(present(badCohort)) badCohort=n
            WRITE (*,*),'UPDATE_POOL: Cohort',n,'of',pool%n_cohorts,'bad'
            call print_cohort(pool%litterCohorts(n))
            WRITE (*,*),'Dissolved carbon =',pool%dissolved_carbon
            WRITE (*,*),'Latest respiration:',tempResp*dt
            WRITE (*,*),'Previous unprotected C:',prevC
            WRITE (*,*),'Previous unprotected N:',prevN
            WRITE (*,*),'Pool Nitrate:',pool%nitrate
            WRITE (*,*),'Pool ammonium:',pool%ammonium
        ENDIF

        C_loss_rate=C_loss_rate+tempresp
        N_loss_rate=N_loss_rate+temp_N_decomposed

        protected_C_produced=protected_C_produced+temp_protected
        protected_N_produced=protected_N_produced+temp_N_protected

        protected_turnover_rate=protected_turnover_rate+temp_protected_turnover_rate
        protected_N_turnover_rate=protected_N_turnover_rate+temp_protected_N_turnover_rate

        deadmic_C_produced=deadmic_C_produced+temp_deadmic_C
        deadmic_N_produced=deadmic_N_produced+temp_deadmic_N

        ! livemic_C_produced=livemic_C_produced+temp_livemic_C! kg/m2
        ! livemic_N_produced=livemic_N_produced+temp_livemic_N  ! xz kg/m2

        CO2prod=CO2prod+tempCO2

        soil_MINERAL=soil_MINERAL+temp_MINERAL  ! xz kg/m2
        soil_IMM_N=soil_IMM_N+tempIMM_N ! xz kg/m2
        denitrification = denitrification + denitrif*dt ! kgN/m2

!        if (is_watch_point()) then
!           __DEBUG4__(cohortVolume,T,theta,air_filled_porosity)
!           __DEBUG3__(Prate_limited,tempCO2,CO2prod)
!        endif
    ENDDO


    ! Xin had N uptake here.  I'm moving it to somewhere in vegetation
    IF (soil_carbon_option == SOILC_CORPSE_N) THEN
        !!Nitrification and denitrification after updating all cohorts
        !!!!!!!!!!!!!!xz Check to add N2O emission, change the gamma_nitr to account nitrogen lost during the nitrification and denitrification processes
    	nitrif=min(pool%ammonium,Knitrif(T)*(max(theta,0.0)**3)*max((max(air_filled_porosity,0.0))**gas_diffusion_exp,min_anaerobic_resp_factor)*pool%ammonium*dt)   !xz CHECK with Gerber's paper(or LM3 code)   kg/m2
    	!      kg/m2       kg/m2         yr-1                                                                                      kg/m2         yr
    	pool%nitrif=pool%nitrif + nitrif!xz  --BNS: changed to cumulative

        pool%ammonium=pool%ammonium-nitrif!xz
        pool%nitrate=pool%nitrate+gamma_nitr*nitrif!xz   gamma_nitr is set to 1 now.
        ! Gaseous N losses are going to break N conservation unless we keep track of them
        !!!!!!!!!!!!!!xz Check [end]

        !!!!!!!!!!!!!xz Denitrification; check with LM3 code; Currently the code only calculate the denitrification rate with Temperature, we might improve it by adding siol water content
        !!!xz CH note: check the theta condition because the denitri may work differently from the rest of proccesses
        IF(denitrif_first_order) then
            IF(theta.gt.denitrif_theta_min)THEN  !xz when the soil water content is higher than minimum soil water content(defined in the parameters), then dinitrification take a potential rate; otherwise it is 0
                            Denitrif=min(pool%nitrate,Kdenitr(T)*pool%nitrate*dt)
               if(Denitrif.lt.dfloat(0))then
                   call error_mesg('update_pool','Denitrif < 0',FATAL)
               endif
            ELSE
               Denitrif=dfloat(0)
            ENDIF

            !!!!!!!!!!!!!xz update the pool
            pool%nitrate=pool%nitrate-denitrif

            denitrification=denitrif
        ENDIF
        pool%denitrif=pool%denitrif+denitrif

        nitrification=nitrif
        N_mineralization = soil_MINERAL
        N_immobilization = soil_IMM_N

    ELSE
        nitrification=0.0
        denitrification=0.0
        N_mineralization = soil_MINERAL
        N_immobilization = soil_IMM_N
    ENDIF

    ! update turnover rates
    total = totalPoolCohort(pool)
    where (total%litterC(:)>0) &
        pool%C_turnover(:) = pool%C_turnover(:)+C_loss_rate(:)/total%litterC(:)
    where (total%litterN(:)>0) &
        pool%N_turnover(:) = pool%N_turnover(:)+N_loss_rate(:)/total%litterN(:)
    where (total%protectedC(:)>0) &
        pool%protected_C_turnover(:) = pool%protected_C_turnover(:)+protected_turnover_rate(:)/total%protectedC(:)
    where (total%protectedN(:)>0) &
        pool%protected_N_turnover(:) = pool%protected_N_turnover(:)+protected_N_turnover_rate(:)/total%litterN(:)
end subroutine update_pool


! Do litter respiration and microbial turnover for one litter cohort
subroutine update_cohort(cohort,nitrate,ammonium,cohortVolume,T,theta,air_filled_porosity,protection_rate,protection_rate_N,dt,&
        totalResp,deadmic_C_produced,deadmic_N_produced,protected_produced,protected_N_produced,&
        protected_turnover_rate,protected_N_turnover_rate,CO2prod,totalN_decomposed,IMM_Nprod,MINERAL_prod,denitrif,livemic_C_produced,livemic_N_produced) ! xz
    type(litterCohort),intent(inout)::cohort
    real,intent(out)::totalResp(N_C_TYPES),CO2prod,protected_produced(N_C_TYPES),protected_N_produced(N_C_TYPES),protected_turnover_rate(N_C_TYPES), &
        protected_N_turnover_rate(N_C_TYPES),deadmic_C_produced,deadmic_N_produced,IMM_Nprod,MINERAL_prod,denitrif,livemic_C_produced,livemic_N_produced
    real,intent(in)::cohortVolume,T,theta,dt,protection_rate(N_C_TYPES),protection_rate_N(N_C_TYPES) ! Temperature, volumetric water content, delta time
    real,intent(in)::air_filled_porosity
    real,intent(inout)::nitrate, ammonium
    real::frac_nitrate,frac_ammonium

    real::microbeTurnover,temp_C_microbes,CN_imbalance_term,temp_N_microbes
    real::potential_tempResp(N_C_TYPES),tempResp(N_C_TYPES)
    real,dimension(N_C_TYPES)::protectedCTurnover,newProtectedC,protectedNturnover,newProtectedN

    real::totalN_decomposed(N_C_TYPES)
    real::pot_tempN_decomposed(N_C_TYPES), potential_N_decomp(N_C_TYPES),tempN_decomposed(N_C_TYPES)
    real::denitrif_NO3_demand ! kgN/m2/year
    real,dimension(N_C_TYPES):: denitrif_Resp,pot_tempN_decomposed_denitrif ! kgC/m2/year
    real::carbon_supply_denitrif,nitrogen_supply_denitrif

    real :: N_inhibitory_factor
    integer::i

    integer :: N_lim_state  ! Keep track of N limitation in this time step for debugging
    integer, parameter :: EXCESS_N = 1, N_LIMITED = 2, IMMOBILIZATION = 3, N_LIM_TURNED_OFF = -999

    real :: maintenance_resp,overflow_resp,carbon_supply,nitrogen_supply !!BNS

    maintenance_resp=0.0
    overflow_resp=0.0
    carbon_supply=0.0
    nitrogen_supply=0.0


    CN_imbalance_term=0.0
    totalResp=0.0
    potential_tempResp=0.0
    tempResp=0.0
    CO2prod=0.0
    deadmic_C_produced=0.0
    deadmic_N_produced=0.0
    livemic_C_produced=0.0
    livemic_N_produced=0.0

    totalN_decomposed=0.0
    pot_tempN_decomposed=0.0
    tempN_decomposed=0.0
    potential_N_decomp(N_C_TYPES)=0.0

    MINERAL_prod=0.0
    IMM_Nprod=0.0

    if(.NOT. check_cohort(cohort)) THEN
       call print_cohort(cohort)
       call error_mesg('update_cohort','Cohort invalid at beginning of subroutine',FATAL)
    endif


    ! Calculate potential respiration rate (if not N limited)
    ! Litter
    potential_tempResp=Resp(cohort%litterC,cohort%livingMicrobeC,T,theta,air_filled_porosity)

    ! Respiration of carbon supported by denitrification rather than oxygen; kgC/m2/yr
    denitrif_Resp=Resp_denitrif(cohort%litterC,cohort%livingMicrobeC,T,theta,air_filled_porosity,nitrate)
    ! Factor based on stoichiometry of denitrification; kgN/m2/yr
    denitrif_NO3_demand=sum(denitrif_Resp)*denitrif_NO3_factor

    if(denitrif_NO3_demand*dt>nitrate) then
        denitrif_Resp = denitrif_Resp*nitrate/(denitrif_NO3_demand*dt)
        denitrif_NO3_demand=nitrate/dt
    endif

    ! print *,air_filled_porosity,nitrate,denitrif_NO3_demand,sum(denitrif_Resp),sum(potential_tempResp)

    ! potential_tempResp = potential_tempResp + denitrif_Resp

    ! Make sure it does not exceed available C
    where(dt*potential_tempResp > cohort%litterC)
        potential_tempResp=cohort%litterC/dt
    end where

    ! This needs to be changed if Vmax can be different for C vs nitrogen
    if(soil_carbon_option == SOILC_CORPSE_N) then
        where(cohort%litterC>0)
            pot_tempN_decomposed=potential_tempResp*cohort%litterN/cohort%litterC ! kgC/m2/yr
            pot_tempN_decomposed_denitrif=denitrif_Resp*cohort%litterN/cohort%litterC
        elsewhere
            pot_tempN_decomposed=0.0
            pot_tempN_decomposed_denitrif=0.0
        end where


        cohort%IMM_N_max=min((ammonium+nitrate)/dt-denitrif_NO3_demand,cohort%livingMicrobeC*(V_NH4(T)*ammonium+V_NO3(T)*nitrate)*(theta**3)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor))   ! kg/m2/yr
        nitrogen_supply=sum(pot_tempN_decomposed*mup)
        nitrogen_supply_denitrif=sum(pot_tempN_decomposed_denitrif*mup)
        temp_N_microbes=cohort%livingMicrobeN
    endif

    microbeTurnover=max(0.0,(cohort%livingMicrobeC-minMicrobeC*sum(cohort%litterC))/Tmic)   ! kg/m2/yr

    carbon_supply=sum(potential_tempResp*eup)
    carbon_supply_denitrif=sum(denitrif_Resp*eup)

    maintenance_resp=microbeTurnover*(1.0-et)

    ! Update microbial biomass
    temp_C_microbes=cohort%livingMicrobeC

    IF(soil_carbon_option == SOILC_CORPSE_N) THEN

        carbon_supply = carbon_supply+carbon_supply_denitrif
        nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

        if(carbon_supply - maintenance_resp > (nitrogen_supply+cohort%IMM_N_max)*CN_microb) THEN
            ! Growth is nitrogen limited, with not enough mineral N to support it with max immobilization
            N_LIM_STATE=N_LIMITED
            CN_imbalance_term = -cohort%IMM_N_max

            ! Just skip denitrifaction in this case for now, since it probably doesn't amount to much if mineral N is limiting microbial growth
            ! Probably better to do this with implicit solution at some point :-(
            ! denitrif_Resp = 0.0
            ! denitrif_NO3_demand = 0.0

            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            if(N_limit_scheme==NLIM_OVERFLOW) THEN
                !!OPTION1: no impact on decomposition rate

                livemic_C_produced=dt*((nitrogen_supply-CN_imbalance_term)*CN_microb + maintenance_resp)
                livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)

                cohort%livingMicrobeN = cohort%livingMicrobeN + livemic_N_produced - dt*(microbeTurnover*et/CN_microb)
                cohort%livingMicrobeC = cohort%livingMicrobeC + livemic_C_produced - dt*(microbeTurnover)
                overflow_resp=carbon_supply - livemic_C_produced/dt


                tempResp=potential_tempResp + denitrif_resp ! *N_inhibitory_factor  ! Actual amount of carbon decomposed
                tempN_decomposed=pot_tempN_decomposed + pot_tempN_decomposed_denitrif ! *N_inhibitory_factor  ! Actual amount of nitrogen decomposed

                ! print *,'overflow_resp',overflow_resp
                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            elseif(N_limit_scheme==NLIM_DOWNREGULATE) THEN
                !!OPTION2: only change decomposition rate

                !!!!!!Inhibition factor
                N_inhibitory_factor=(CN_imbalance_term-(1-et)*microbeTurnover/CN_microb)/(nitrogen_supply-carbon_supply/CN_microb)

                !sum(mup(i)*cohort%litterN(i)/cohort%litterC(i)-eup(i)/CN_microb)
                tempResp=potential_tempResp *N_inhibitory_factor  !Actual amount of carbon decomposed
                tempN_decomposed=pot_tempN_decomposed *N_inhibitory_factor  !Actual amount of nitrogen decomposed


                !update carbon and nitrogen supply
                carbon_supply=sum(tempResp*eup)
                nitrogen_supply=sum(tempN_decomposed*mup)

                livemic_C_produced=dt*((nitrogen_supply-CN_imbalance_term)*CN_microb + maintenance_resp)
                livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)

                cohort%livingMicrobeN = cohort%livingMicrobeN + livemic_N_produced - dt*(microbeTurnover*et/CN_microb)
                cohort%livingMicrobeC = cohort%livingMicrobeC + livemic_C_produced - dt*(microbeTurnover)
                overflow_resp=carbon_supply - livemic_C_produced/dt

                livemic_C_produced=dt*(nitrogen_supply-CN_imbalance_term)
                livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)/CN_microb
            else
                call error_mesg('update_cohort','Invalid N-limit_scheme',FATAL)
            endif

        elseif(carbon_supply - maintenance_resp >= (nitrogen_supply)*CN_microb) THEN
            ! Growth must be supported by immobilization of some mineral nitrogen, but is ultimately carbon limited
            N_LIM_STATE = IMMOBILIZATION

            ! carbon_supply = carbon_supply+carbon_supply_denitrif
            ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

            CN_imbalance_term = -((carbon_supply-maintenance_resp)/CN_microb - nitrogen_supply)
            cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
            cohort%livingMicrobeN = cohort%livingMicrobeN + dt*((carbon_supply-maintenance_resp)/CN_microb - microbeTurnover*et/CN_microb)

            livemic_C_produced=dt*carbon_supply
            livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb

            tempResp=potential_tempResp+denitrif_Resp ! Note, waste from denitrif still goes to CO2 !Actual amount of carbon decomposed
            tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif  !Actual amount of nitrogen decomposed
            overflow_resp=0

        elseif(carbon_supply>=maintenance_resp) THEN
            ! Growth is carbon limited -- extra N is mineralized
            N_LIM_STATE = EXCESS_N

            ! carbon_supply = carbon_supply+carbon_supply_denitrif
            ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

            cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
            cohort%livingMicrobeN = cohort%livingMicrobeN + dt*((carbon_supply-maintenance_resp)/CN_microb - microbeTurnover*et/CN_microb)
            CN_imbalance_term = nitrogen_supply - (carbon_supply-maintenance_resp)/CN_microb

            tempResp=potential_tempResp+denitrif_Resp  !Actual amount of carbon decomposed
            tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif  !Actual amount of nitrogen decomposed
            overflow_resp=0
            livemic_C_produced=dt*carbon_supply ! Note, waste from denitrif still goes to CO2
            livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb

        else
            ! Maintenance resp exceeds carbon supply. In this case, some additional biomass N will be lost
            N_LIM_STATE = EXCESS_N

            ! carbon_supply = carbon_supply+carbon_supply_denitrif
            ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

            cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
            cohort%livingMicrobeN = cohort%livingMicrobeN + dt*(carbon_supply/CN_microb - microbeTurnover/CN_microb)

            tempResp=potential_tempResp+denitrif_Resp ! Note, waste from denitrif still goes to CO2
            tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif
            overflow_resp=0.0
            CN_imbalance_term = nitrogen_supply-(carbon_supply-maintenance_resp)/CN_microb

            livemic_C_produced=dt*carbon_supply
            livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb
        endif

        ! Enforce correct microbial C:N. Model has been having problems with slow increase in microbial C relative to N.
        ! This feels a bit kloodgy but hopefully shouldn't cause problems
        if(cohort%livingMicrobeC > (CN_microb+1e-3)*cohort%livingMicrobeN) then
            ! Too much microbial C. Respire extra C
            overflow_resp = overflow_resp + (cohort%livingMicrobeC - cohort%livingMicrobeN*CN_microb)
            cohort%livingMicrobeC = cohort%livingMicrobeC - (cohort%livingMicrobeC - cohort%livingMicrobeN*CN_microb)
        endif
        if(cohort%livingMicrobeC < (CN_microb-1e-3)*cohort%livingMicrobeN) then
            ! Too much microbial N. Mineralize extra N
            CN_imbalance_term = CN_imbalance_term + (cohort%livingMicrobeN - cohort%livingMicrobeC/CN_microb)
            cohort%livingMicrobeN = cohort%livingMicrobeN - (cohort%livingMicrobeN - cohort%livingMicrobeC/CN_microb)
        endif

        ! !Check for validity of C/N
        IF(cohort%livingMicrobeN<0) then
            print *,'et',et
            print *,'microbeTurnover',microbeTurnover*dt
            print *,'microbeTurnover_N',microbeTurnover*et/CN_microb*dt
            print *,'CN_imbalance_term',CN_imbalance_term
            print *,'N_LIM_STATE', N_LIM_STATE
            print *,'N supply',dt*nitrogen_supply
            print *,'livemic_N_produced',livemic_N_produced
            print *,'carbon_supply',carbon_supply
            print *,'maintenance_resp',maintenance_resp
            print *,'dN for live microb N',dt*(sum(mup*tempN_decomposed)-CN_imbalance_term-(microbeTurnover*et)/CN_microb)
            print *,'theta',theta
            print *,'T',T
            print *,'IMM_max',cohort%IMM_N_max
            print *,'ammonium',ammonium
            print *,'nitrate',nitrate
            print *,'Live microbe N',cohort%livingMicrobeN
            print *,'Immobilized inorganic N',cohort%IMM_N_gross*dt
            print *,'Mineralized organic N',cohort%MINER_gross*dt
            print *,'Denitrified NO3',denitrif_NO3_demand
            print *,'Denitrification resp',denitrif_Resp
            print *,'Previous microbe N',temp_N_microbes
            print *,'Previous microbe C',temp_C_microbes
            print *,'dt',dt
            print *,'Live microbe C',cohort%livingMicrobeC

            call print_cohort(cohort)
            call error_mesg('update_cohort','Microbe N < 0',FATAL)
        ENDIF

        if(cohort%livingMicrobeN>1d-8) then
           IF(abs((cohort%livingMicrobeC/cohort%livingMicrobeN)-CN_microb).ge.1d-5)THEN
               WRITE(*,*)'The fix C/N microbial ratio is not respected after the decomposition processes'
               write(*,*)'C/N',cohort%livingMicrobeC/cohort%livingMicrobeN
               call print_cohort(cohort)
               call error_mesg('update_cohort','Microbe C:N not preserved',FATAL)
           ENDIF
        endif

        IF(cohort%livingMicrobeC<0) then
            print *,'Live microbe C',cohort%livingMicrobeC
            print *,'Respired C',tempResp*dt
            print *,'microbe turnover',dt*microbeTurnover
            print *,'Previous microbe C',temp_C_microbes
            print *,'dt',dt
            call print_cohort(cohort)
            call error_mesg('update_cohort','Microbe C < 0',FATAL)
        ENDIF

        deadmic_C_produced=dt*microbeTurnover*et
        cohort%litterC(3)=cohort%litterC(3)+deadmic_C_produced! kg/m2

        deadmic_N_produced=dt*microbeTurnover*et/CN_microb! xz
        cohort%litterN(3)=cohort%litterN(3)+deadmic_N_produced! xz  ! kg/m2


        IF(CN_imbalance_term.ge.0.0)THEN
            cohort%IMM_N_gross=0.0
            cohort%MINER_gross=sum((1-mup)*tempN_decomposed)+CN_imbalance_term
        ELSE
            cohort%IMM_N_gross=-CN_imbalance_term
            cohort%MINER_gross=sum((1-mup)*tempN_decomposed)
        ENDIF


        if(cohort%IMM_N_gross<0.0 .OR. cohort%MINER_gross<0.0) then
            print *,'Immob',cohort%IMM_N_gross
            print *,'Mineralization',cohort%MINER_gross

            print *,'et',et
            print *,'microbeTurnover',microbeTurnover*dt
            print *,'microbeTurnover_N',microbeTurnover*et/CN_microb*dt
            print *,'CN_imbalance_term',CN_imbalance_term
            print *,'N_LIM_STATE', N_LIM_STATE
            print *,'N supply',dt*nitrogen_supply
            print *,'livemic_N_produced',livemic_N_produced
            print *,'carbon_supply',carbon_supply
            print *,'maintenance_resp',maintenance_resp
            print *,'dN for live microb N',dt*(sum(mup*tempN_decomposed)-CN_imbalance_term-(microbeTurnover*et)/CN_microb)
            print *,'theta',theta
            print *,'T',T
            print *,'IMM_max',cohort%IMM_N_max
            print *,'ammonium',ammonium

            print *,'nitrate',nitrate
            print *,'Live microbe N',cohort%livingMicrobeN
            print *,'Immobilized inorganic N',cohort%IMM_N_gross*dt
            print *,'Mineralized organic N',cohort%MINER_gross*dt
            print *,'Previous microbe N',temp_N_microbes
            print *,'Previous microbe C',temp_C_microbes
            print *,'dt',dt
            print *,'Live microbe C',cohort%livingMicrobeC

            call print_cohort(cohort)
            call error_mesg('update_cohort','N Min < 0 or N immob < 0',FATAL)
        endif

        ! This includes denitrification resp added above
        CO2prod=dt*(sum(tempResp*(1.0-eup))+microbeTurnover*(1.0-et)+overflow_resp) ! kg/m2
        ! This includes denitrification resp added above
        cohort%litterC=cohort%litterC-dt*tempResp     ! kg/m2

        !-----update quantity of available nitrate and ammonium in soil -----------------------------------------
        if(.NOT. denitrif_first_order)  nitrate = nitrate - denitrif_NO3_demand*dt

        ! Mineralized N goes to NH4
        ammonium = ammonium + cohort%MINER_gross*dt

        ! Immobilized N taken up from NO3 and NH4
        IF((V_NH4(T)*ammonium+V_NO3(T)*nitrate) > 0)THEN
           frac_nitrate=V_NO3(T)*nitrate/(V_NH4(T)*ammonium+V_NO3(T)*nitrate)
           frac_ammonium = 1.0-frac_nitrate
        ELSE
           frac_nitrate=0.5
           frac_ammonium=0.5
        ENDIF
        nitrate = nitrate - cohort%IMM_N_gross*frac_nitrate*dt
        ammonium = ammonium - cohort%IMM_N_gross*frac_ammonium*dt

        ! IF((V_NH4(T)*ammonium+V_NO3(T)*nitrate).gt.dfloat(0))THEN
        !     nitrate=nitrate+min(CN_imbalance_term,dfloat(0))*(V_NO3(T)*(nitrate)/(V_NH4(T)*ammonium+V_NO3(T)*nitrate))*dt
        !     ammonium=ammonium+max(CN_imbalance_term,dfloat(0))*dt+min(CN_imbalance_term,dfloat(0))*dt*(V_NH4(T)*(ammonium)/(V_NH4(T)*ammonium+V_NO3(T)*nitrate))+sum((1-mup)*tempN_decomposed)*dt
        ! ELSE
        !     nitrate=nitrate+(min(CN_imbalance_term,dfloat(0))/2)*dt
        !     ammonium=ammonium+max(CN_imbalance_term,dfloat(0))*dt+min(CN_imbalance_term,dfloat(0))/2*dt+(sum((1-mup)*tempN_decomposed))*dt
        ! ENDIF
    ELSE ! if not SOILC_CORPSE_N
        N_LIM_STATE = N_LIM_TURNED_OFF
        tempResp=potential_tempResp
        ! C-only model order of operations was remove decomposed litter first
        where(dt*tempResp > cohort%litterC)
            tempResp=cohort%litterC/dt
            cohort%litterC=0.0
        elsewhere
            cohort%litterC=cohort%litterC-dt*tempResp
        end where
        ! Update microbial biomass
        temp_C_microbes=cohort%livingMicrobeC
        microbeTurnover=max(0.0,(cohort%livingMicrobeC-minMicrobeC*sum(cohort%litterC))/Tmic)
        cohort%livingMicrobeC=cohort%livingMicrobeC + dt*(sum(eup*tempResp) - microbeTurnover)
        livemic_C_produced=dt*(sum(eup*tempResp))
        deadmic_C_produced=dt*microbeTurnover*et
        cohort%litterC(3)=cohort%litterC(3)+deadmic_C_produced

        CO2prod=dt*(sum(tempResp*(1.0-eup))+microbeTurnover*(1.0-et))

        IF(cohort%livingMicrobeC<0) then
            print *,'Live microbe C',cohort%livingMicrobeC
                print *,'Respired C',tempResp*dt
            print *,'microbe turnover',dt*microbeTurnover
                print *,'Previous microbe C',temp_C_microbes
            print *,'dt',dt
            call print_cohort(cohort)
            call error_mesg('update_cohort','Microbe C < 0',FATAL)
        ENDIF

        tempN_decomposed = 0.0
        cohort%IMM_N_gross=0.0
        cohort%MINER_gross=0.0
        deadmic_N_produced=0.0
        livemic_N_produced=0.0
        denitrif_NO3_demand=0.0
    ENDIF

    ! Update the amount of organic C and N in the cohort after the decomposition process

    ! Removal of C from cohort done above to preserve correct order of operations
    ! cohort%litterC=cohort%litterC-dt*tempResp     ! kg/m2
    totalResp=totalResp+tempResp                  ! kg/m2/yr

    cohort%litterN=cohort%litterN-dt*tempN_decomposed     ! kg/m2
    totalN_decomposed=totalN_decomposed+tempN_decomposed   ! kg/m2/yr

    IMM_Nprod=cohort%IMM_N_gross*dt             ! kg/m2 ! Gross immobilization of inorganic nitrogen for the cohort
    MINERAL_prod=cohort%MINER_gross*dt          ! kg/m2 ! Gross mineralization of organic nitrogen for the cohort

    cohort%MINER_prod=cohort%MINER_prod+cohort%MINER_gross*dt
    cohort%IMM_Nprod=cohort%IMM_Nprod+cohort%IMM_N_gross*dt


    cohort%CO2=cohort%CO2+CO2prod

    cohort%Rtot=cohort%Rtot+sum(totalResp)

    denitrif = denitrif_NO3_demand

    if(.NOT. check_cohort(cohort)) THEN
       call print_cohort(cohort)
       print *,'N limitation type',N_LIM_STATE
       print *,'CO2 produced',CO2prod
       print *,'Overflow resp',overflow_resp*dt
       print *,'CN imbalance',CN_imbalance_term*dt
       print *,'C supply',carbon_supply*dt
       print *,'N supply',nitrogen_supply*dt
       print *,'Microbe C prod',livemic_C_produced
       print *,'Microbe N prod',livemic_N_produced
       print *,'Dead mic C prod',deadmic_C_produced
       print *,'Dead mic N prod',deadmic_N_produced
       print *,'Maintenance resp',maintenance_resp*dt
       print *,'Uptake resp',totalResp*(1.0-eup)*dt
       print *,'Denitrif',denitrif_NO3_demand
       print *,'Cohort C - required total',cohortCSum(cohort)-cohort%originalLitterC
       print *,'Nitrate',nitrate
       call error_mesg('update_cohort','Cohort invalid',FATAL)
    endif


    ! Update protected carbon
    protectedCturnover = cohort%protectedC/tProtected

    IF(sum(cohort%litterC).gt.0.0 .and. cohortVolume.gt.0.0) THEN
        ! Change: divide by volume instead of litter C. Keeps it linear with size, but allows dependence on unprotected C
        if (microbe_driven_protection) then
            newProtectedC(:) = protection_rate*cohort%livingMicrobeC/cohortVolume*cohort%litterC(:)*dt
        else
            newProtectedC(:) = protection_rate*cohort%litterC(:)*dt
        endif
    ELSE
        newProtectedC = 0.0
    ENDIF
    where(newProtectedC.gt.cohort%litterC) newProtectedC=cohort%litterC
    cohort%protectedC = cohort%protectedC + newProtectedC - dt*protectedCturnover
    cohort%litterC = cohort%litterC - newProtectedC + dt*protectedCturnover

    protected_produced=newProtectedC
    protected_turnover_rate=protectedCturnover

    IF(soil_carbon_option == SOILC_CORPSE_N) THEN
        protectedNturnover = cohort%protectedN/tProtected_N  ! xz
        IF(sum(cohort%litterN).gt.0.0 .and. cohortVolume.gt.0.0) THEN
            ! Change: divide by volume instead of litter C. Keeps it linear with size, but allows dependence on unprotected C
            if (microbe_driven_protection) then
                newProtectedN(:) = protection_rate*cohort%livingMicrobeC/cohortVolume*cohort%litterN(:)*dt
            else
                newProtectedN(:) = protection_rate*cohort%litterN(:)*dt
            endif
        ELSE
            newProtectedN = 0.0
        ENDIF
        where(newProtectedN.gt.cohort%litterN) newProtectedN=cohort%litterN
        cohort%protectedN = cohort%protectedN + newProtectedN - dt*protectedNturnover
        cohort%litterN = cohort%litterN - newProtectedN + dt*protectedNturnover

        protected_N_produced=newProtectedN  ! kg/m2
        protected_N_turnover_rate=protectedNturnover  ! kg/m2/year
    ELSE
        protected_N_produced=0.0
        protected_N_turnover_rate=0.0
    ENDIF

end subroutine update_cohort





! COPIED FROM VEGN_DYNAMICS
! ============================================================================
! The combined reduction in decomposition rate as a funciton of TEMP and MOIST
! Based on CENTURY Parton et al 1993 GBC 7(4):785-809 and Bolker's copy of
! CENTURY code
elemental function A_function(soilt, theta) result(A)
  real :: A                 ! return value, resulting reduction in decomposition rate
  real, intent(in) :: soilt ! effective temperature for soil carbon decomposition
  real, intent(in) :: theta

  real :: soil_temp; ! temperature of the soil, deg C
  real :: Td; ! rate multiplier due to temp
  real :: Wd; ! rate reduction due to mositure

  ! coefficeints and terms used in temperaturex term
  real :: Topt,Tmax,t1,t2,tshl,tshr;

  soil_temp = soilt-273.16;

  ! EFFECT OF TEMPERATURE
  ! from Bolker's century code
  Tmax=45.0;
  if (soil_temp > Tmax) soil_temp = Tmax;
  Topt=35.0;
  tshr=0.2; tshl=2.63;
  t1=(Tmax-soil_temp)/(Tmax-Topt);
  t2=exp((tshr/tshl)*(1.-t1**tshl));
  Td=t1**tshr*t2;

  if (soil_temp > -10) Td=Td+0.05;
  if (Td > 1.) Td=1.;

  ! EFFECT OF MOISTURE
  ! Linn and Doran, 1984, Soil Sci. Amer. J. 48:1267-1272
  ! This differs from the Century Wd
  ! was modified by slm/ens based on the figures from the above paper
  !     (not the reported function)

  if(theta <= 0.3) then
     Wd = 0.2;
  else if(theta <= 0.6) then
     Wd = 0.2+0.8*(theta-0.3)/0.3;
  else
     Wd = exp(2.3*(0.6-theta));
  endif

  A = (Td*Wd); ! the combined (multiplicative) effect of temp and water
               ! on decomposition rates
end function A_function


pure subroutine initializeCohort(cohort,litterInputC,litterInputN,initialMicrobeC,initialMicrobeN,initialProtectedC,initialProtectedN,multiplier,CO2)
    type(litterCohort),intent(out)::cohort
    real,intent(in),optional::litterInputC(N_C_TYPES),litterInputN(N_C_TYPES),CO2
    real,intent(in),optional::multiplier
    real,intent(in),optional::initialMicrobeC,initialMicrobeN
    real,intent(in),optional::initialProtectedC(N_C_TYPES),initialProtectedN(N_C_TYPES)

    real::litterInputCval(N_C_TYPES),litterInputNval(N_C_TYPES)
    real::initialMicrobeCval,initialMicrobeNval,CO2val,multiplierval
    real::initialProtectedCval(N_C_TYPES),initialProtectedNval(N_C_TYPES)

    litterInputCval=0.0
    litterInputNval=0.0
    initialProtectedCval=0.0
    initialProtectedNval=0.0
    initialMicrobeCval=0.0
    initialMicrobeNval=0.0
    CO2val=0.0
    multiplierval=1.0

    if (present(litterInputC)) litterInputCval=litterInputC
    if (present(litterInputN)) litterInputNval=litterInputN
    if (present(initialprotectedC)) initialProtectedCval=initialProtectedC
    if (present(initialprotectedN)) initialProtectedNval=initialProtectedN
    if (present(initialMicrobeC)) initialMicrobeCval=initialMicrobeC

    ! Should we make sure microbe C:N is correct?
    if (present(initialMicrobeN)) initialMicrobeNval=initialMicrobeN
    if (present(CO2)) CO2val=CO2
    if (present(multiplier)) multiplierval=multiplier


    ! originalLitterC is there to check carbon conservation
    cohort%originalLitterC=(sum(litterInputCval)+CO2val+initialMicrobeCval+sum(initialProtectedCval))*multiplierval
    cohort%litterC=litterInputCval*multiplierval
    cohort%protectedC=initialProtectedCval*multiplierval
    cohort%livingMicrobeC=initialMicrobeCval*multiplierval
    cohort%CO2=CO2val*multiplierval
    cohort%Rtot=0.0

    cohort%originalLitterN=(sum(litterInputNval)+initialMicrobeNval+sum(initialProtectedNval))*multiplierval
    cohort%litterN=litterInputNval*multiplierval
    cohort%protectedN=initialProtectedNval*multiplierval
    cohort%livingMicrobeN=initialMicrobeNval*multiplierval

    cohort%MINER_prod=0.0
    cohort%IMM_Nprod=0.0
    cohort%MINER_gross=0.0
    cohort%IMM_N_gross=0.0
    cohort%IMM_N_max=0.0

end subroutine initializeCohort


pure function Resp(Ctotal,Chet,T,theta,air_filled_porosity)
    real,intent(in)::Chet                ! heterotrophic (microbial) C
    real,intent(in)::T,theta             ! temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity ! Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in)::Ctotal(N_C_TYPES)   ! Substrate C
    real,dimension(N_C_TYPES)::Resp
    real::enz,Cavail(N_C_TYPES)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    ! Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp=0.0
        return
    ENDIF

    where (Cavail>0)
      Resp=Vmax(T)*theta**3*(Cavail)*enz/(Cavail*kC+enz)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor*aerobic_max)
  elsewhere
     Resp=0.0
   endwhere

end function Resp



pure function Resp_denitrif(Ctotal,Chet,T,theta,air_filled_porosity,nitrate)
    real,intent(in)::Chet                       ! heterotrophic (microbial) C
    real,intent(in)::T,theta                    ! temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity        ! Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in),dimension(N_C_TYPES)::Ctotal ! Substrate C
    real,intent(in)::nitrate                     ! Available nitrate
    real,dimension(N_C_TYPES)::Resp_denitrif,tempresp
    real::denitrif_NO3_demand
    real::enz,Cavail(N_C_TYPES)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    ! Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp_denitrif=0.0
        return
    ENDIF

    where(Cavail>0)
      tempresp=Vmax_denitrif(T)*(Cavail)*enz/(Cavail*kC+enz)*theta**3*max(0.0,(denitrif_theta_min-air_filled_porosity**gas_diffusion_exp))*aerobic_max
    elsewhere
      tempresp=0.0
    endwhere

    ! Actual denitrification rate as limited by NO3 concentration; kgN/m2/yr
    ! k_denitrif relates demand (rate) to NO3 pool for rate limitation
    denitrif_NO3_demand=sum(tempresp)*denitrif_NO3_factor

    if(nitrate>0.0) then
      Resp_denitrif = tempresp * nitrate/(nitrate + k_denitrif*denitrif_NO3_demand)
    else
      resp_denitrif = 0.0
    endif



end function Resp_denitrif


pure function Resp_myc(Ctotal,Chet,T,theta,air_filled_porosity)
    real,intent(in)::Chet                       ! heterotrophic (microbial) C
    real,intent(in)::T,theta                    ! temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity        ! Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in),dimension(N_C_TYPES)::Ctotal ! Substrate C
    real,dimension(N_C_TYPES)::Resp_myc,tempresp
    real::enz,Cavail(N_C_TYPES)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    ! Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp_myc=0.0
        return
    ENDIF

    where(Cavail>0)
      Resp_myc=Vmax_myc(T)*theta**3*(Cavail)*enz/(Cavail*k_myc_decomp+enz)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor*aerobic_max)
    elsewhere
      Resp_myc=0.0
    endwhere

    !ox_avail=oxygen_concentration(Ox,sum(tempresp)/sum(Cavail)*theta*oxPerC)
    !print *,sum(tempresp)/sum(Cavail)
    !print *,ox_avail/(kO+ox_avail)
    !print *,tempresp*(1.0-theta)+theta*tempresp*ox_avail/(kO+ox_avail)

    ! Assumes pores are either saturated or not oxygen limited, divided according to theta
    ! Resp=tempresp*(1.0-theta)+theta*tempresp*ox_avail/(kO+ox_avail)
end function Resp_myc


pure function Vmax(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(N_C_TYPES)::alpha,Vmax

    alpha=vmaxref/exp(-Ea/(Rugas*Tref))
    Vmax=alpha*exp(-Ea/(Rugas*T))
end function Vmax

pure function Vmax_denitrif(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(N_C_TYPES)::alpha,Vmax_denitrif

    alpha=vmaxref_denitrif/exp(-Ea/(Rugas*Tref))
    Vmax_denitrif=alpha*exp(-Ea/(Rugas*T))
end function Vmax_denitrif

pure function Vmax_myc(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(N_C_TYPES)::alpha,Vmax_myc

    alpha=vmaxref_myc_decomp/exp(-Ea/(Rugas*Tref))
    Vmax_myc=alpha*exp(-Ea/(Rugas*T))
end function Vmax_myc




! Calculates the rate of [Arbuscular] mycorrhizal uptake of mineral N in the pool.
! This is a function of mycorrhizal biomass concentration and mineral N in the layer
pure subroutine mycorrhizal_mineral_N_uptake_rate(pool,myc_biomass,layer_thickness,nitrate_uptake,ammonium_uptake)
  type(soil_pool),intent(in)::pool
  real,intent(in)::myc_biomass             ! (kgC/m2)
  real,intent(in)::layer_thickness         ! (m)
  real,intent(out)::nitrate_uptake         ! (kgN/m2/year)
  real,intent(out)::ammonium_uptake        ! (kgN/m2/year)


  ! This is a Michaelis-Menton function of mycorrhizal biomass concentration and total mineral N
  nitrate_uptake = pool%nitrate/layer_thickness/(pool%nitrate/layer_thickness + k_conc_myc_min_N_uptk)*Vmax_myc_min_N_uptk*&
          (myc_biomass/layer_thickness)/(k_myc_min_N_uptk+myc_biomass/layer_thickness)*layer_thickness
  ammonium_uptake = pool%ammonium/layer_thickness/(pool%ammonium/layer_thickness + k_conc_myc_min_N_uptk)*Vmax_myc_min_N_uptk*&
          (myc_biomass/layer_thickness)/(k_myc_min_N_uptk+myc_biomass/layer_thickness)*layer_thickness

end subroutine mycorrhizal_mineral_N_uptake_rate


! Calculates rate of N mineralization from miner (ecto) mycorrhizae, WITH changing pools
subroutine mycorrhizal_decomposition(pool,myc_biomass,T,theta,air_filled_porosity,N_uptake,C_uptake,CO2prod,dt,update_pools)
  type(soil_pool),intent(inout)::pool
  real,intent(in)::myc_biomass,dt,T,theta,air_filled_porosity
  real,intent(out)::N_uptake,C_uptake,CO2prod
  logical, intent(in) :: update_pools ! if True, then update C and N pools

  integer :: nn
  real :: cohort_myc_biomass  ! Distribute among cohorts
  real :: totalCarbon, weight, potential_tempResp(N_C_TYPES), pot_tempN_decomposed(N_C_TYPES)

  N_uptake = 0.0
  C_uptake = 0.0
  CO2prod = 0.0

  call poolTotals(pool,totalCarbon=totalCarbon)

  do nn=1,pool%n_cohorts

    ! Weight myc biomass by cohort size
    IF(totalCarbon.gt.0) THEN
       weight=cohortCsum(pool%litterCohorts(nn),only_active=.TRUE.)/totalCarbon
    ELSE
       weight=1.0
    ENDIF

    cohort_myc_biomass = myc_biomass*weight

    potential_tempResp=Resp_myc(pool%litterCohorts(nn)%litterC,cohort_myc_biomass,T,theta,air_filled_porosity)

    ! Make sure it does not exceed available C
    where(dt*potential_tempResp > pool%litterCohorts(nn)%litterC)
        potential_tempResp=pool%litterCohorts(nn)%litterC/dt
    end where

    where(pool%litterCohorts(nn)%litterC>0)
        pot_tempN_decomposed=potential_tempResp*pool%litterCohorts(nn)%litterN/pool%litterCohorts(nn)%litterC ! kgC/m2/yr
    elsewhere
        pot_tempN_decomposed=0.0
    end where

    C_uptake = C_uptake + sum(potential_tempResp*eup_myc)*dt
    N_uptake = N_uptake + sum(pot_tempN_decomposed*mup_myc)*dt
    CO2prod = CO2prod + sum(potential_tempResp*(1-eup_myc))*dt

    if (update_pools) then
       pool%litterCohorts(nn)%litterC = pool%litterCohorts(nn)%litterC - potential_tempResp*dt
       pool%litterCohorts(nn)%litterN = pool%litterCohorts(nn)%litterN - pot_tempN_decomposed*dt
       pool%litterCohorts(nn)%originalLitterC = pool%litterCohorts(nn)%originalLitterC - sum(potential_tempResp*eup_myc)*dt
       pool%litterCohorts(nn)%originalLitterN = pool%litterCohorts(nn)%originalLitterN - sum(pot_tempN_decomposed)*dt
       pool%litterCohorts(nn)%CO2 = pool%litterCohorts(nn)%CO2 + sum(potential_tempResp*(1-eup_myc))*dt
       pool%ammonium = pool%ammonium + sum(pot_tempN_decomposed*(1.0-mup_myc))*dt
    endif
  enddo

end subroutine mycorrhizal_decomposition

! =============================================================================
! prints on-line state of the carbon cohort
subroutine debug_cohort(c)
   type(litterCohort), intent(in) :: c
   __DEBUG___(c%litterC)
   __DEBUG___(c%protectedC)
   __DEBUG___(c%livingMicrobeC)
   __DEBUG___(c%CO2)
   __DEBUG___(c%originalLitterC)

   __DEBUG___(c%litterN)
   __DEBUG___(c%protectedN)
   __DEBUG___(c%livingMicrobeN)
   __DEBUG___(c%originalLitterN)
   write(*,*)
end subroutine debug_cohort

! =============================================================================
! Add nitrogen stuff to this?
subroutine debug_pool(p,tag)
   type(soil_pool), intent(in) :: p
   character(*), intent(in) :: tag

   integer :: i
   write(*,'(x,a)',advance='NO')trim(tag)
   __DEBUG5__(p%max_cohorts,p%n_cohorts,p%protection_rate,p%Qmax,p%dissolved_carbon)
!   do i = 1, p%n_cohorts
!      write(*,'(x,i3.3)',advance='NO')i
!      call debug_cohort(p%litterCohorts(i))
!   enddo
end subroutine debug_pool


subroutine print_cohort(cohort)
    type(litterCohort)::cohort

    WRITE (*,*),'----------------'
    WRITE (*,*),'Original C =',cohort%originalLitterC
    WRITE (*,*),'Unprotected C=',cohort%litterC
    WRITE (*,*),'Living microbial C =',cohort%livingMicrobeC
    WRITE (*,*),'Protected C =',cohort%protectedC

    WRITE (*,*),'CO2 =',cohort%CO2
    WRITE (*,*),'Rtot =',cohort%Rtot
    WRITE (*,*),'Sum of carbon =',cohortCsum(cohort)
    WRITE (*,*),'----------------'

    WRITE (*,*),'----------------'
    WRITE (*,*),'Original N =',cohort%originalLitterN
    WRITE (*,*),'Unprotected N=',cohort%litterN
    WRITE (*,*),'Living microbial N =',cohort%livingMicrobeN
    WRITE (*,*),'Protected N =',cohort%protectedN

    WRITE (*,*),'gross miner =',cohort%MINER_prod
    WRITE (*,*),'gross Immobil =',cohort%IMM_Nprod
    WRITE (*,*),'last miner =',cohort%MINER_gross
    WRITE (*,*),'last immob =',cohort%IMM_N_gross
    WRITE (*,*),'Sum of nitrogen =',cohortNsum(cohort)

    if(cohort%livingMicrobeN>0) WRITE(*,*), 'Microbe C:N =',cohort%livingMicrobeC/cohort%livingMicrobeN
end subroutine


! Check for carbon balance and invalid values
logical function check_cohort(cohort) result(cohortGood)
    type(litterCohort),intent(in)::cohort
    integer::n
    logical:: tempGood
    real :: cohortC
    ! ZMS
    real,parameter :: tol_roundoff = 1.e-11    ! [kg C/m^2] tolerance for roundoff error in soil carbon numerics

    cohortGood=.NOT. ( &
     (min(cohort%originalLitterC,cohort%livingMicrobeC,cohort%CO2,cohort%livingMicrobeN).lt.-tol_roundoff) .OR. &
    isNAN(cohort%originalLitterC) .OR. &
    isNAN(cohort%livingMicrobeC) .OR. &
    isNAN(cohort%CO2)  .OR. &
    (min(cohort%originalLitterN,cohort%livingMicrobeN).lt.0) .OR. &
    isNAN(cohort%originalLitterN) .OR. &
    isNAN(cohort%livingMicrobeN) &
    )

   cohortC=cohortCSum(cohort)
  !if(cohortC .GT. 0.0) cohortGood = cohortGood .AND. (abs(cohortC-cohort%originalLitterC)/cohortC) .LT. tol
  ! ZMS Make this an either relative or absolute balance check to allow roundoff error for infinitessimal pools in deep layers
    if(cohortC .GT. 0.0) cohortGood = cohortGood .AND. &
              (abs(cohortC-cohort%originalLitterC)/cohortC .LT. tol .OR. abs(cohortC-cohort%originalLitterC) .LT. tol_roundoff)

    DO n=1,N_C_TYPES
        tempGood = .NOT. ( &
        (cohort%litterC(n).lt.-tol_roundoff) .OR. &
        (cohort%protectedC(n).lt.-tol_roundoff) .OR. &
        (cohort%litterN(n).lt.-tol_roundoff) .OR. &
        (cohort%protectedN(n).lt.-tol_roundoff) .OR. &
        (isNAN(cohort%litterC(n))) .OR. &
        (isNAN(cohort%protectedC(n)))  .OR. &
        (isNAN(cohort%litterN(n))) .OR. &
        (isNAN(cohort%protectedN(n)))  &
        )
        cohortGood=cohortGood .AND. tempGood
    ENDDO


    cohortGood = cohortGood .AND. (cohort%IMM_N_gross>=-tol_roundoff) .AND. (cohort%MINER_gross>=-tol_roundoff)

    ! IF(.NOT. cohortGood) THEN
!        WRITE (*,*)'Cohort carbon pool error:'
!        call print_cohort(cohort)
!        WRITE (*,*)'Sum =',cohortCSum(cohort),'Difference =',cohortCSum(cohort)-(cohort%originalLitterC)
    !    call error_mesg('Dsdt','Found bad cohort in fineWood litter',FATAL)
    !  ENDIF


 if(cohort%livingMicrobeN>0) then
    IF(abs((cohort%livingMicrobeC/cohort%livingMicrobeN)-CN_microb).ge.1d-1)THEN
      cohortGood = .FALSE.
    ENDIF
 endif


end function check_cohort



function cohortCSum(cohort,only_active)
    type(litterCohort),intent(in)::cohort
    logical,intent(in),optional::only_active
    real::tempSum
    real::cohortCSum

    logical::only_act

    only_act=.FALSE.
    if(present(only_active)) only_act=only_active


    tempSum=0.0
    tempSum=tempSum+cohort%livingMicrobeC
    tempSum=tempSum+sum(cohort%litterC)
    tempSum=tempSum+sum(cohort%protectedC)
    !tempSum=tempSum+sum(cohort%minC)
    if (.NOT. only_act) then
        tempSum=tempSum+cohort%CO2
    endif
    cohortCSum=tempSum
END FUNCTION

 function cohortNSum(cohort,only_active)
    type(litterCohort),intent(in)::cohort
    logical,intent(in),optional::only_active
    real::tempSum
    real::cohortNSum

    logical::only_act

    only_act=.FALSE.
    if(present(only_active)) only_act=only_active

    tempSum=0.0
    tempSum=tempSum+cohort%livingMicrobeN
    tempSum=tempSum+sum(cohort%litterN)
    tempSum=tempSum+sum(cohort%protectedN)
  !  tempSum=tempSum+(cohort%MINER_gross-cohort%IMM_N_gross)
    if(only_act) then
      tempSum=tempSum+(cohort%MINER_prod-cohort%IMM_Nprod)
    endif

    cohortNSum=tempSum
END FUNCTION


! Add a cohort to the soil carbon pool
subroutine add_cohort(pool,newCohort)
    type(soil_pool),intent(inout) :: pool
    type(litterCohort),intent(in) :: newCohort

    type(litterCohort),allocatable::newCohorts(:)

    if (.not.allocated(pool%litterCohorts)) then
       allocate(pool%litterCohorts(init_n_cohorts))
       pool%n_cohorts = 0
    endif

    if (pool%n_cohorts+1>size(pool%litterCohorts)) then
       ! not enough room for new cohort in the array of cohorts, reallocate
       ! cohort array: double its size
       allocate(newCohorts(2*size(pool%litterCohorts)))
       newCohorts(1:pool%n_cohorts) = pool%litterCohorts(1:pool%n_cohorts)
       call move_alloc(from=newCohorts,to=pool%litterCohorts)
    endif

    pool%litterCohorts(pool%n_cohorts+1) = newCohort
    pool%n_cohorts = pool%n_cohorts+1
end subroutine add_cohort


! Adds litter as a new cohort
subroutine add_litter(pool,newLitterC,newLitterN,rhizosphere_frac)
  type(soil_pool),intent(inout)::pool
  real,intent(in) :: newLitterC(N_C_TYPES),newLitterN(N_C_TYPES)
  real,intent(in),optional :: rhizosphere_frac

  type(litterCohort)::newCohort,tempCohort
  real::initialMicrobeC,initialMicrobeN
  real::rhiz_frac
  real,dimension(N_C_TYPES)::N_type_fracs,C_type_fracs

  if(sum(newLitterC)>0) then
    C_type_fracs=newLitterC/sum(newLitterC)
  else
    C_type_fracs=0.0
  endif

  if(sum(newLitterN)>0) then
    N_type_fracs=newLitterN/sum(newLitterN)
  else
    N_type_fracs=0.0
  endif

  rhiz_frac=1.0
  if(present(rhizosphere_frac)) rhiz_frac=max(0.0,min(1.0,rhizosphere_frac))

  ! new carbon and nitrogen must be non-negative
  call check_var_range(newLitterC, 0.0, HUGE(1.0), 'add_litter', 'newLitterC', FATAL)
  call check_var_range(newLitterN, 0.0, HUGE(1.0), 'add_litter', 'newLitterN', FATAL)

  initialMicrobeC=sum(newLitterC*minMicrobeC)
  ! More important to conserve N, or to make sure there is some initial microbial biomass?
  ! We could just assume enough fixers to ensure some minimal initial biomass?
  ! Currently limiting by N: could suppress decomposition for low-N litter, especially with rhizosphere_cohort OFF
  if(soil_carbon_option == SOILC_CORPSE_N) then
      initialMicrobeN=min(sum(newLitterN),initialMicrobeC/CN_microb)
      if (initialMicrobeN<initialMicrobeC/CN_microb) initialMicrobeC=initialMicrobeN*CN_microb
  else
      initialMicrobeN=0.0
  endif

  if (.NOT. use_rhizosphere_cohort) then
      call initializeCohort(newCohort, &
              litterInputC=newLitterC-initialMicrobeC*C_type_fracs, initialMicrobeC=initialMicrobeC, &
              litterInputN=newLitterN-initialMicrobeN*N_type_fracs, initialMicrobeN=initialMicrobeN)
      call add_cohort(pool,newCohort)
  else
      ! First make sure there are enough cohorts in pool
      do while (pool%n_cohorts<max(BULK,RHIZ))
          call initializeCohort(newCohort)
          call add_cohort(pool,newCohort)
      enddo

      ! Add rhizosphere fraction
      call initializeCohort(newCohort, &
              litterInputC=newLitterC-initialMicrobeC*C_type_fracs, initialMicrobeC=initialMicrobeC, &
              litterInputN=newLitterN-initialMicrobeN*N_type_fracs, initialMicrobeN=initialMicrobeN, &
              multiplier=rhiz_frac)
      call combine_cohorts(newCohort,pool%litterCohorts(RHIZ),tempCohort)
      pool%litterCohorts(RHIZ)=tempCohort

      ! Add bulk soil fraction
      call initializeCohort(newCohort,&
              litterInputC=newLitterC-initialMicrobeC*C_type_fracs, initialMicrobeC=initialMicrobeC, &
              litterInputN=newLitterN-initialMicrobeN*N_type_fracs, initialMicrobeN=initialMicrobeN, &
              multiplier=1.0-rhiz_frac)
      call combine_cohorts(newCohort,pool%litterCohorts(BULK),tempCohort)
      pool%litterCohorts(BULK)=tempCohort
  endif

  pool%C_in(:) = pool%C_in(:) + newLitterC(:)
  pool%N_in(:) = pool%N_in(:) + newLitterN(:)
end subroutine add_litter


! Add carbon to all cohorts in pool, weighted by cohort size.
! For leaching or exudation that is spread evenly in soil instead of new cohort
subroutine add_C_N_to_cohorts(pool,litterC,protectedC,livingMicrobeC,CO2,litterN,protectedN,livingMicrobeN)
    type(soil_pool),intent(inout)::pool
    real,optional,dimension(N_C_TYPES),intent(in)::litterC,protectedC,litterN,protectedN
    real,optional,intent(in)::livingMicrobeC,CO2,livingMicrobeN

    real,dimension(N_C_TYPES)::litterCval,protectedCval,litterNval,protectedNval
    real::livingMicrobeCval,CO2val,livingMicrobeNval
    real::totalCarbon,weight
    integer::ii

    livingMicrobeCval=0.0
    protectedCval=0.0
    litterCval=0.0
    CO2val=0.0

    livingMicrobeNval=0.0
    protectedNval=0.0
    litterNval=0.0

    IF (present(litterC)) litterCval=litterC
    IF (present(protectedC)) protectedCval=protectedC
    IF (present(livingMicrobeC)) livingMicrobeCval=livingMicrobeC
    IF (present(CO2)) CO2val=CO2

    IF (present(litterN)) litterNval=litterN
    IF (present(protectedN)) protectedNval=protectedN
    IF (present(livingMicrobeN)) livingMicrobeNval=livingMicrobeN

    IF (any(litterCval<0) .or. any(protectedCval<0) .or. livingMicrobeCval<0 .or. CO2val<0) &
          call error_mesg('add_carbon_to_cohorts','Carbon added less than zero',FATAL)
    IF (any(litterNval<0) .or. any(protectedNval<0) .or. livingMicrobeNval<0) &
        call error_mesg('add_carbon_to_cohorts','Nitrogen added less than zero',FATAL)

    call poolTotals(pool,totalCarbon=totalCarbon)
    if(.not.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    DO ii=1,pool%n_cohorts
        ! Deposited carbon is just weighted by total cohort carbon, which we assume tracks with soil volume and mass
        IF(totalCarbon.gt.0) THEN
           weight=cohortCsum(pool%litterCohorts(ii),only_active=.TRUE.)/totalCarbon
        ELSE
           weight=1.0
        ENDIF

        pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC+litterCval*weight
        pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC+protectedCval*weight
        pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC+livingMicrobeCval*weight
        pool%litterCohorts(ii)%CO2=pool%litterCohorts(ii)%CO2+CO2val*weight
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC+(sum(litterCval+protectedCval)+livingMicrobeCval+CO2val)*weight

        if(soil_carbon_option == SOILC_CORPSE_N) then  ! May be unnecessary to "if" this if these are always zero?
            pool%litterCohorts(ii)%litterN=pool%litterCohorts(ii)%litterN+litterNval*weight! xz
            pool%litterCohorts(ii)%protectedN=pool%litterCohorts(ii)%protectedN+protectedNval*weight! xz
            pool%litterCohorts(ii)%livingMicrobeN=pool%litterCohorts(ii)%livingMicrobeN+livingMicrobeNval*weight! xz
            pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN+(sum(litterNval+protectedNval)+livingMicrobeNval)*weight! xz
        endif
    ENDDO

    pool%C_in(:) = pool%C_in(:) + LitterCval(:) ! slm: should we also add livingMicrobeCval or CO2val?
    pool%N_in(:) = pool%N_in(:) + LitterNval(:)
    pool%protected_C_in(:) = pool%protected_C_in(:) + protectedCval(:)
    pool%protected_N_in(:) = pool%protected_N_in(:) + protectedNval(:)
end subroutine add_C_N_to_cohorts


subroutine add_C_N_to_rhizosphere(pool,newCarbon,newNitrogen)
    type(soil_pool),intent(inout)::pool
    real,intent(in)::newCarbon(N_C_TYPES)
    real,intent(in),optional :: newNitrogen(N_C_TYPES)


    real :: newNitrogenVal(N_C_TYPES)
    type(litterCohort)::rhizosphere,newcohort
    integer::n

    newNitrogenVal = 0.0
    if(present(newNitrogen)) newNitrogenVal = newNitrogen

    if(.NOT. use_rhizosphere_cohort) then
        !call remove_carbon_fraction_from_pool(pool,rhizosphere_frac,litter_removed,protected_removed,liveMicrobe_removed)
        !call initializeCohort(rhizosphere,litter_removed+newCarbon,liveMicrobe_removed)
        !call add_cohort(pool,rhizosphere)
        ! -- Note, I don't think this implementation was used, and it is problematic because it gets called so often

        ! Matching prior implementation, this carbon is just spread through soil
        call add_C_N_to_cohorts(pool,litterC=newCarbon,litterN=newNitrogenVal)
    else
        call initializeCohort(newcohort,newCarbon,newNitrogenVal)
        ! New functionality: Rhizosphere is a fixed cohort, just add carbon to that
        ! Ignores rhizosphere_frac
        call combine_cohorts(newcohort,pool%litterCohorts(RHIZ),rhizosphere)
        pool%litterCohorts(RHIZ)=rhizosphere
        pool%C_in(:) = pool%C_in(:) + newCarbon(:)
        pool%N_in(:) = pool%N_in(:) + newNitrogenVal(:)
    endif

    do n=1,pool%n_cohorts
       IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
            WRITE (*,*),'add_C_N_to_rhizosphere: Cohort',n,'of',pool%n_cohorts,'bad'
            call print_cohort(pool%litterCohorts(n))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo
end subroutine add_C_N_to_rhizosphere



! Remove a fraction of carbon from all cohorts.  For processes like leaching and bioturbation
subroutine remove_C_N_fraction_from_pool(pool,fractionC,fractionN,litterC_removed,protectedC_removed,liveMicrobeC_removed,&
        litterN_removed,protectedN_removed,liveMicrobeN_removed,&
        C_litterMobility,C_protectedMobility,N_litterMobility,N_protectedMobility,&
        livingMicrobeMobility)
    type(soil_pool),intent(inout) :: pool
    real,intent(in) :: fractionC,fractionN
    real,intent(out) :: litterC_removed(N_C_TYPES),protectedC_removed(N_C_TYPES),liveMicrobeC_removed
    real,intent(out) :: litterN_removed(N_C_TYPES),protectedN_removed(N_C_TYPES),liveMicrobeN_removed
    real,intent(in), optional :: C_litterMobility(N_C_TYPES),C_protectedMobility,N_litterMobility(N_C_TYPES),N_protectedMobility,livingMicrobeMobility

    integer::ii
    real::temp,temp2(N_C_TYPES)
    real::C_litterFactor(N_C_TYPES),N_litterFactor(N_C_TYPES),C_protectedFactor,N_protectedFactor,liveMicrobeFactor

    C_litterFactor=1.0
    C_protectedFactor=1.0
    N_litterFactor=1.0
    N_protectedFactor=1.0
    liveMicrobeFactor=1.0

    IF (present(C_litterMobility)) C_litterFactor=C_litterMobility
    IF (present(C_protectedMobility)) C_protectedFactor=C_protectedMobility
    IF (present(N_litterMobility)) N_litterFactor=N_litterMobility
    IF (present(N_protectedMobility)) N_protectedFactor=N_protectedMobility
    IF (present(livingMicrobeMobility)) liveMicrobeFactor=livingMicrobeMobility

    if(fractionC>1.0) call error_mesg('remove_C_N_fraction_from_pool','fractionC > 1.0',FATAL)
    if(fractionN>1.0) call error_mesg('remove_C_N_fraction_from_pool','fractionN > 1.0',FATAL)


    litterC_removed=0.0
    protectedC_removed=0.0
    liveMicrobeC_removed=0.0
    litterN_removed=0.0
    protectedN_removed=0.0
    liveMicrobeN_removed=0.0

    IF(allocated(pool%litterCohorts)) THEN
       DO ii=1,pool%n_cohorts
           ! Carbon
           temp2=pool%litterCohorts(ii)%litterC*min(1.0,fractionC)*C_litterFactor
           litterC_removed=litterC_removed+temp2
           pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC-temp2
           pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

           temp2=pool%litterCohorts(ii)%protectedC*min(1.0,fractionC)*C_protectedFactor
           protectedC_removed=protectedC_removed+temp2
           pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC-temp2
           pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

           temp=pool%litterCohorts(ii)%livingMicrobeC*min(1.0,fractionC)*liveMicrobeFactor
           liveMicrobeC_removed=liveMicrobeC_removed+temp
           pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC-temp
           pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-temp

           ! Nitrogen
           if(soil_carbon_option == SOILC_CORPSE_N) THEN
               temp2=pool%litterCohorts(ii)%litterN*min(1.0,fractionN)*N_litterFactor
               litterN_removed=litterN_removed+temp2
               pool%litterCohorts(ii)%litterN=pool%litterCohorts(ii)%litterN-temp2
               pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-sum(temp2)

               temp2=pool%litterCohorts(ii)%protectedN*min(1.0,fractionN)*N_protectedFactor
               protectedN_removed=protectedN_removed+temp2
               pool%litterCohorts(ii)%protectedN=pool%litterCohorts(ii)%protectedN-temp2
               pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-sum(temp2)

               temp=pool%litterCohorts(ii)%livingMicrobeN*min(1.0,fractionN)*liveMicrobeFactor
               liveMicrobeN_removed=liveMicrobeN_removed+temp
               pool%litterCohorts(ii)%livingMicrobeN=pool%litterCohorts(ii)%livingMicrobeN-temp
               pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-temp
           ELSE
               litterN_removed=0.0
               protectedN_removed=0.0
               liveMicrobeN_removed=0.0
           ENDIF
       ENDDO
    ENDIF
    pool%C_in(:) = pool%C_in(:) - litterC_removed(:)
    pool%N_in(:) = pool%N_in(:) - litterN_removed(:)
    pool%protected_C_in(:) = pool%protected_C_in(:) - protectedC_removed(:)
    pool%protected_N_in(:) = pool%protected_N_in(:) - protectedN_removed(:)

end subroutine remove_C_N_fraction_from_pool


subroutine remove_cohort(pool,num)
    type(soil_pool),intent(inout)::pool
    integer,intent(in)::num

    integer :: i
    !PRINT *,'Removing cohort',num
    IF (num > pool%n_cohorts) call error_mesg('remove_cohort','Tried to remove nonexistent soil cohort', FATAL)

    do i = num, pool%n_cohorts-1
       pool%litterCohorts(i) = pool%litterCohorts(i+1)
    enddo
    pool%n_cohorts = pool%n_cohorts - 1
    ! note that the cohort array does not shrink, because it is likely it'll
    ! need to be expanded in the future
end subroutine remove_cohort



subroutine combine_cohorts(cohort1,cohort2,result)
    type(litterCohort),intent(in)::cohort1,cohort2
    type(litterCohort),intent(out)::result

    call initializeCohort(result)

    result%litterC=(cohort1%litterC + cohort2%litterC)
    result%protectedC=cohort1%protectedC + cohort2%protectedC
    result%litterN=(cohort1%litterN + cohort2%litterN)
    result%protectedN=cohort1%protectedN + cohort2%protectedN

    result%livingMicrobeC=(cohort1%livingMicrobeC + cohort2%livingMicrobeC)
    result%livingMicrobeN=(cohort1%livingMicrobeN + cohort2%livingMicrobeN)

    result%CO2=(cohort1%CO2 + cohort2%CO2)
    result%Rtot=(cohort1%Rtot + cohort2%Rtot)
    result%originalLitterC=(cohort1%originalLitterC + cohort2%originalLitterC)
    result%originalLitterN=(cohort1%originalLitterN + cohort2%originalLitterN)! xz
    result%MINER_prod=(cohort1%MINER_prod + cohort2%MINER_prod)! xz
    result%IMM_Nprod=(cohort1%IMM_Nprod + cohort2%IMM_Nprod)! xz
    result%MINER_gross=(cohort1%MINER_gross + cohort2%MINER_gross)
    result%IMM_N_gross=(cohort1%IMM_N_gross + cohort2%IMM_N_gross)
    ! Cbefore=cohortCsum(cohort1)*cohort1%cohortVolume+cohortCsum(cohort2)*cohort2%cohortVolume
    ! Cafter=cohortCsum(result)*result%cohortVolume

    ! IF (Cbefore.ne.Cafter) PRINT *,'Error in combining cohorts:',Cafter-Cbefore

    if(.NOT. check_cohort(result)) then
        print *,'Invalid cohort generated'
        call print_cohort(result)
        call error_mesg('combine_cohorts','Resulting cohort invalid',FATAL)
    endif
end subroutine combine_cohorts


! Returns the cohort with all fields multiplied by x
pure function multiply_cohort(cohort,x) result(result)
    type(litterCohort),intent(in) :: cohort
    real,intent(in) :: x
    type(litterCohort) :: result

    call initializeCohort(cohort=result,litterInputC=cohort%litterC,litterInputN=cohort%litterN, &
                                        initialMicrobeC=cohort%livingMicrobeC,initialMicrobeN=cohort%livingMicrobeN, &
                                        initialProtectedC=cohort%protectedC,initialProtectedN=cohort%protectedN, &
                                        multiplier=x,CO2=cohort%CO2)
    result%Rtot=cohort%Rtot*x

    ! Need to check these
    result%IMM_Nprod=result%IMM_Nprod*x
    result%MINER_prod=result%MINER_prod*x
    result%IMM_N_gross=result%IMM_N_gross*x
    result%MINER_gross=result%MINER_gross*x

end function multiply_cohort


! Combine two soil_pools, with weighting
subroutine combine_pools(pool1,pool2,w1,w2)
    type(soil_pool),intent(in) :: pool1
    type(soil_pool),intent(inout) :: pool2
    real :: w1,w2,x1,x2
    integer::cc

    ! Make sure weights are normalized
    x1 = w1/(w1+w2)
    x2 = 1.0 - x1

    ! First multiply existing cohorts by weighting
    IF(pool2%n_cohorts>0) THEN
    DO cc=1,pool2%n_cohorts
        pool2%litterCohorts(cc)=multiply_cohort(pool2%litterCohorts(cc),x2)
    ENDDO
    ENDIF

    ! Then just add the cohorts in pool1 to pool2, with weights
    ! Note: Should this do something different if using rhizosphere and bulk soil structure?
    IF (pool1%n_cohorts>0) THEN
    DO cc=1,pool1%n_cohorts
        call add_cohort(pool2,multiply_cohort(pool1%litterCohorts(cc),x1))
    ENDDO
    ENDIF

    call cull_cohorts(pool2)
    pool2%dissolved_carbon=pool2%dissolved_carbon*x2 + pool1%dissolved_carbon*x1
    pool2%dissolved_nitrogen=pool2%dissolved_nitrogen*x2 + pool1%dissolved_nitrogen*x1
    pool2%ammonium=pool2%ammonium*x2 + pool1%ammonium*x1
    pool2%nitrate=pool2%nitrate*x2 + pool1%nitrate*x1
    pool2%nitrif=pool2%nitrif*x2 + pool1%nitrif*x1
    pool2%denitrif=pool2%denitrif*x2 + pool1%denitrif*x1
end subroutine combine_pools


! transfers a fraction of one pool into another, preserving cohorts
! Should this do something different for the rhiz and bulk soil structure?
subroutine transfer_pool_fraction(source, destination, fraction)
    type(soil_pool), intent(inout) :: source, destination
    real, intent(in) :: fraction

    integer::nn
    type(litterCohort)::transfer_cohort

    call check_var_range(fraction,0.0,1.0,'transfer_pool_fraction','fraction',FATAL)

    do nn=1,source%n_cohorts
        transfer_cohort=multiply_cohort(source%litterCohorts(nn),fraction)
        call add_cohort(destination,transfer_cohort)
        source%litterCohorts(nn)=multiply_cohort(source%litterCohorts(nn),1.0-fraction)
    enddo

    destination%dissolved_carbon=destination%dissolved_carbon+source%dissolved_carbon*fraction
    source%dissolved_carbon=source%dissolved_carbon*(1.0-fraction)

    destination%dissolved_nitrogen=destination%dissolved_nitrogen+source%dissolved_nitrogen*fraction
    source%dissolved_nitrogen=source%dissolved_nitrogen*(1.0-fraction)

    destination%ammonium=destination%ammonium+source%ammonium*fraction
    source%ammonium=source%ammonium*(1.0-fraction)

    destination%nitrate=destination%nitrate+source%nitrate*fraction
    source%nitrate=source%nitrate*(1.0-fraction)

    destination%nitrif=destination%nitrif+source%nitrif*fraction
    source%nitrif=source%nitrif*(1.0-fraction)

    destination%denitrif=destination%denitrif+source%denitrif*fraction
    source%denitrif=source%denitrif*(1.0-fraction)

    do nn=1,source%n_cohorts
         IF (.NOT. check_cohort(source%litterCohorts(nn))) THEN
              WRITE(*,*),'transfer_pool_fraction: Cohort',nn,'of',source%n_cohorts,'bad'
            call print_cohort(source%litterCohorts(nn))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo


    do nn=1,destination%n_cohorts
         IF (.NOT. check_cohort(destination%litterCohorts(nn))) THEN
              WRITE(*,*),'transfer_pool_fraction: Cohort',nn,'of',destination%n_cohorts,'bad'
            call print_cohort(destination%litterCohorts(nn))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo


end subroutine

! Sums all cohorts in layer into a single cohort
type(litterCohort) function totalPoolCohort(pool)
    type(litterCohort)::tempCohort
    type(soil_pool),intent(in)::pool
    integer::ii


    call initializeCohort(totalPoolCohort)

    do ii=1,pool%n_cohorts
        call combine_cohorts(pool%litterCohorts(ii),totalPoolCohort,tempCohort)
        totalPoolCohort=tempCohort
    enddo
end function



 subroutine poolTotals(pool,fastC,fastN,slowC,slowN,deadMicrobeC,deadMicrobeN,liveMicrobeC,liveMicrobeN,protectedC,protectedN,&
        fast_dissolvedC,slow_dissolvedC,deadmic_dissolvedC,fast_dissolvedN,slow_dissolvedN,deadmic_dissolvedN,ncohorts,totalCarbon,totalNitrogen,&
        fast_protectedC,slow_protectedC,deadmic_protectedC,fast_protectedN,slow_protectedN,deadmic_protectedN)
    real, intent(out),optional::fastC,fastN,slowC,slowN,deadMicrobeC,deadMicrobeN,&
                                liveMicrobeC,liveMicrobeN,protectedC,protectedN,totalCarbon,totalNitrogen,&
                                fast_dissolvedC,slow_dissolvedC,deadmic_dissolvedC,fast_dissolvedN,slow_dissolvedN,deadmic_dissolvedN,&
                                fast_protectedC,slow_protectedC,deadmic_protectedC,fast_protectedN,slow_protectedN,deadmic_protectedN
    integer, intent(out),optional::ncohorts
    type(soil_pool),intent(in)::pool

    type(litterCohort)::totalCohort
    integer::n

    totalCohort=totalPoolCohort(pool)

    if (present(fastC)) fastC=totalCohort%litterC(1)
    if (present(fastN)) fastN=totalCohort%litterN(1)
    if (present(slowC)) slowC=totalCohort%litterC(2)
    if (present(slowN)) slowN=totalCohort%litterN(2)
    if (present(deadMicrobeC)) deadMicrobeC=totalCohort%litterC(3)
    if (present(deadMicrobeN)) deadMicrobeN=totalCohort%litterN(3)
    if (present(liveMicrobeC)) liveMicrobeC=totalCohort%livingMicrobeC
    if (present(liveMicrobeN)) liveMicrobeN=totalCohort%livingMicrobeN
    if (present(protectedC)) protectedC=sum(totalCohort%protectedC)
    if (present(protectedN)) protectedN=sum(totalCohort%protectedN)
    if (present(fast_protectedC)) fast_protectedC=totalCohort%protectedC(1)
    if (present(fast_protectedN)) fast_protectedN=totalCohort%protectedN(1)
    if (present(slow_protectedC)) slow_protectedC=totalCohort%protectedC(2)
    if (present(slow_protectedN)) slow_protectedN=totalCohort%protectedN(2)
    if (present(deadmic_protectedC)) deadmic_protectedC=totalCohort%protectedC(3)
    if (present(deadmic_protectedN)) deadmic_protectedN=totalCohort%protectedN(3)
    if (present(fast_dissolvedC)) fast_dissolvedC=pool%dissolved_carbon(1)
    if (present(slow_dissolvedC)) slow_dissolvedC=pool%dissolved_carbon(2)
    if (present(deadmic_dissolvedC)) deadmic_dissolvedC=pool%dissolved_carbon(3)
    if (present(fast_dissolvedN)) fast_dissolvedN=pool%dissolved_nitrogen(1)
    if (present(slow_dissolvedN)) slow_dissolvedN=pool%dissolved_nitrogen(2)
    if (present(deadmic_dissolvedN)) deadmic_dissolvedN=pool%dissolved_nitrogen(3)
    if (present(totalCarbon)) totalCarbon=sum(totalCohort%litterC)+sum(totalCohort%protectedC)+&
            totalCohort%livingMicrobeC+sum(pool%dissolved_carbon)
    if (present(totalNitrogen)) totalNitrogen=sum(totalCohort%litterN)+sum(totalCohort%protectedN)+&
            totalCohort%livingMicrobeN+sum(pool%dissolved_nitrogen)+pool%ammonium+pool%nitrate

    if (present(ncohorts)) then
        ncohorts=0
        do n=1,pool%n_cohorts
            if (cohortCsum(pool%litterCohorts(n)).gt.0.0) ncohorts=ncohorts+1
        enddo
    endif
end subroutine poolTotals

 subroutine poolTotals1(pool, litterC, litterN, livemicC, livemicN, &
        dissolvedC, dissolvedN, protectedC, protectedN, totalC, totalN, ncohorts)
    type(soil_pool), intent(in) :: pool
    real, intent(out), dimension(N_C_TYPES), optional :: &
        litterC,    litterN,    &
        protectedC, protectedN, &
        dissolvedC, dissolvedN
    real, intent(out), optional :: &
        totalC, totalN, &
        livemicC,livemicN
    integer, intent(out), optional :: ncohorts

    type(litterCohort)::totalCohort
    integer::n

    totalCohort=totalPoolCohort(pool)

    if (present(litterC))    litterC=totalCohort%litterC(:)
    if (present(litterN))    litterN=totalCohort%litterN(:)
    if (present(livemicC))   livemicC=totalCohort%livingMicrobeC
    if (present(livemicN))   livemicN=totalCohort%livingMicrobeN
    if (present(protectedC)) protectedC=totalCohort%protectedC(:)
    if (present(protectedN)) protectedN=totalCohort%protectedN(:)
    if (present(dissolvedC)) dissolvedC=pool%dissolved_carbon(:)
    if (present(dissolvedN)) dissolvedN=pool%dissolved_nitrogen(:)
    if (present(totalC)) totalC=sum(totalCohort%litterC)+sum(totalCohort%protectedC)+&
            totalCohort%livingMicrobeC+sum(pool%dissolved_carbon)
    if (present(totalN)) totalN=sum(totalCohort%litterN)+sum(totalCohort%protectedN)+&
            totalCohort%livingMicrobeN+sum(pool%dissolved_nitrogen)+pool%ammonium+pool%nitrate

    if (present(ncohorts)) then
        ncohorts=0
        do n=1,pool%n_cohorts
            if (cohortCsum(pool%litterCohorts(n)).gt.0.0) ncohorts=ncohorts+1
        enddo
    endif
end subroutine poolTotals1

! Combine cohorts in a pool, making sure the total number is less than the pool max cohorts
subroutine cull_cohorts(pool)
    type(soil_pool),intent(inout)::pool
    integer::n,ncombined,m,c1,c2
    real::Cbefore,Cafter,minDistance,r
    type(litterCohort)::tempCohort

    ncombined=0

    DO WHILE(pool%n_cohorts>pool%max_cohorts)
        ! Find closest pair of cohorts
        minDistance = HUGE(1.0)
        do n = 1, pool%n_cohorts
           do m = n+1, pool%n_cohorts
              r = cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m))
              if (r<minDistance) then
                 minDistance = r; c1=n; c2=m
              endif
           enddo
        enddo
        call combine_cohorts(pool%litterCohorts(c1),pool%litterCohorts(c2),tempCohort)
        ! PRINT '("At cohort ceiling (",I3,"): combined cohorts ",I3," and ",I3,",difference=",F8.3)',pool%max_Cohorts,c1,c2,minDistance
        pool%litterCohorts(c1)=tempCohort
        call remove_cohort(pool,c2)
        ncombined=ncombined+1
    ENDDO

    ! Cafter=cohortCsum(totalCarbonCohort(pool))
    ! IF(ncombined.gt.0) WRITE (*,*),'Combined',ncombined,'cohorts'
    ! totalCombineError=totalCombineError+(Cafter-Cbefore)

end subroutine cull_cohorts



! Calculate a numerical estimate of the difference between two cohorts,
! for deciding which are the closest and can be combined
real function cohortDistance(cohort1,cohort2)
    type(litterCohort)::cohort1,cohort2
    real::sum1,sum2

    !sum1=cohortCsum(cohort1,.TRUE.)
    !sum2=cohortCsum(cohort2,.TRUE.)
    sum1=sum(cohort1%litterC)
    sum2=sum(cohort2%litterC)

    IF (sum1.eq.0.0 .or. sum2.eq.0.0) THEN
        cohortDistance=0.0
    ELSE

        cohortDistance=sqrt(Cpoolcomp(cohort1%litterC(1),sum1,cohort2%litterC(1),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(2),sum1,cohort2%litterC(2),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(3),sum1,cohort2%litterC(3),sum2,.FALSE.)**2 &
                    !+ Cpoolcomp(sum(cohort1%protectedC),sum1,sum(cohort2%protectedC),sum2,.TRUE.)**2 &
                    !+ (Cpoolcomp(cohort1%livingMicrobeC,sum1,cohort2%livingMicrobeC,sum2,.FALSE.))**2 &
                    )

    ENDIF

end function


! Calculate the difference between two cohort carbon pools.  Used to decide if the cohorts can be combined
real function Cpoolcomp(pool1,sum1,pool2,sum2,norm) result(compval)
    real, intent(in)::pool1,sum1,pool2,sum2
    logical,intent(in)::norm
    real::poolmean,pooldiff
    real::normval


    poolmean=0.5*(pool1/sum1+pool2/sum2)
    pooldiff=abs(pool1/sum1-pool2/sum2)

    IF (norm) THEN
        normval=poolmean
    ELSE
        normval=1.0
    ENDIF

    IF (poolmean.EQ.0.0) THEN
    compval=0.0
    ELSE
    compval=pooldiff/normval
    ENDIF
end function

!!!xz this following subroutine is adopted from CH's code using concentration over water; please note that the units of some input variables are different. I kept tracer_advection_ORI following this subroutine
subroutine tracer_advection(tracer_mass,flow,div,dz,del_tracer,divergence_loss,wl)  ! wl was added here compared to the old version
    real,intent(inout),dimension(:):: tracer_mass  ! Per layer (not per unit water)
    real,intent(in),dimension(:)   :: flow  ! Total flow, not flow rate [mm]
    real,intent(in),dimension(:)   :: div   ! Horizontal divergence (layer total, not rate) [mm]
    real,intent(in),dimension(:)   :: dz    ! Layer thickness
    real,intent(in),dimension(:)   :: wl    ! water content [kg/m^2] by layer before Richards (1:num_l)
    real,intent(out),dimension(:)  :: del_tracer,divergence_loss ! Change in tracer mass, and divergence part

    real,dimension(size(tracer_mass)) :: aaa,bbb,ccc,ddd,wl_litter    ! Matrix coefficients for aaa*dx[i-1] + bbb*dx[i] + ccc*dx[i+1] = ddd
    real,dimension(size(tracer_mass)) :: u_minus,u_plus   ! For weighting of flow upstream/downstream
    real,dimension(size(tracer_mass)) :: tracer_concentration ! [kg C/m^3 soil]
    integer::ll,nlayers
    ! real,dimension(size(tracer_mass)) ::flow_eff ! flow adjusted to be units of [m], weighted by 1/wl  ZACK'S CODE
    real, parameter                   :: minwl = 0.1 ! [mm] minimum allowed wl
    real,parameter::dens_h2o=1000.   ! kg/m3
!    real*8,parameter::porosity=0.3  !CH valore inventato  !xz volumn of water over volumn of soil; need to consider to change!!
    !real,intent(in)::theta
    !real*8::dt=1.0/(48.0*365.0)


    nlayers=size(tracer_concentration)
    wl_litter(1)=dz(1)     ! m
    do ll=2,nlayers
      wl_litter(ll)=max(wl(ll-1), minwl)/dens_h2o  ! m
       enddo

    tracer_concentration=tracer_mass/wl_litter   ! kg/m3  ! concentration computed over the volume of water


    u_minus = 1.
    where (flow.lt.0.) u_minus = 0.
    do ll = 1, nlayers-1
        u_plus(ll) = 1. - u_minus(ll+1)
    enddo

    ! Top layer, uses upper bound concentration

    ll=1
    aaa(ll)= 0.0 ! flow(ll)*u_minus(ll)
    bbb(ll)= flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - wl_litter(ll)
  !   m           m                          m                           m

    ! divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)   BEN CODE ORIGINAL
    divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
    ! [kg/m^2]         =       [m]        *    [kg/m^3]

    ccc(ll)= -flow(ll+1)*u_plus(ll)
    ! m

    ddd(ll)= - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll)) - tracer_concentration(ll+1)*ccc(ll)
 !    kg/m2          kg/m3                       m                    kg/m3                 m

    do ll=2,nlayers-1
        !aaa(ll)=flow(ll)*u_minus(ll)     !BEN ORIGINAL
        !bbb(ll)=flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - dz(ll)
        !divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
        !ccc(ll)=-flow(ll+1)*u_plus(ll)
        !ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll)) - tracer_concentration(ll+1)*ccc(ll)

!Adapted from ZACK's CODE
     aaa(ll)=flow(ll)*u_minus(ll)
        bbb(ll)=flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - wl_litter(ll)
        divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)     ! [kg/m^3]
!         kg/m2            =    m           *    kg/m3
        ccc(ll)=-flow(ll+1)*u_plus(ll)   !m
        ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll)) - tracer_concentration(ll+1)*ccc(ll)
   !    kg/m2
    enddo


    !bottom layer, flow out is zero
   ! ll=nlayers
   ! aaa(ll)=flow(ll)*u_minus(ll)
   ! bbb(ll)= flow(ll)*(1-u_minus(ll)) - dz(ll)
   ! divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
   ! ccc(ll)= 0.0
   ! ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll))

!Adapted from ZACK's CODE
    ll=nlayers
    aaa(ll)=flow(ll)*u_minus(ll)
    bbb(ll)= flow(ll)*(1-u_minus(ll)) - wl_litter(ll)
    divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
    ccc(ll)= 0.0
    ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll))


    !Solve the linear algebra problem
    if(nlayers.gt.1) then
        call tridiag(aaa,bbb,ccc,ddd,del_tracer)  !kg/m3
    else
        del_tracer=0.0
    endif


    del_tracer=del_tracer*wl_litter   !kg/m2   !variazione del tracer
    tracer_mass=tracer_mass+del_tracer    !kg/m2
    divergence_loss=divergence_loss

    where(divergence_loss>tracer_mass) divergence_loss=tracer_mass


    !WRITE(10,'(12f20.15)')del_tracer,tracer_mass,divergence_loss

end subroutine tracer_advection

!
!    real,intent(out),optional::del_DOC(:,:)
!
!    real::litterbefore(N_C_TYPES,size(layers))
!    real,dimension(N_C_TYPES,size(layers)) :: dissolved_litter
!    real,dimension(N_C_TYPES,size(layers)) :: div_loss_litter
!    real::d_litter(N_C_TYPES,size(layers))
!    integer::ll,ii,badcohort,n
!    ! ZMS: for debug
!    integer:: i,j,k,face
!
!
!
!    do ii=1,N_C_TYPES
!    litterbefore(ii,:)=layers(:)%dissolved_carbon(ii)
!    if(any(litterbefore(ii,:)<0)) then
!        print *,'Carbon flavor',ii
!        print *,litterbefore(ii,:)
!        call error_mesg('carbon_leaching','Dissolved litter < 0 (before advection)',FATAL)
!    endif
!
!    call tracer_advection(layers(:)%dissolved_carbon(ii),flow(1:size(layers)),div*dt*0,dz,d_litter(ii,:),div_loss_litter(ii,:))
!
!    if(any(layers(:)%dissolved_carbon(ii)<0)) call error_mesg('carbon_leaching','Dissolved litter < 0 (after advection)',FATAL)
!    enddo
!
!    if(present(del_DOC)) del_DOC=d_litter
!
!
! end subroutine tracer_advection_prev





subroutine tracer_leaching_with_litter(soil,wl,leaflitter,woodlitter,flow,litterflow,div,dz,dt,del_soil_DOC,&
                        del_leaflitter_DOC,del_woodlitter_DOC,div_DOC_loss,&
                        tiled,div_hlsp_DOC,surf_DOC_loss,div_hlsp_DON,surf_DON_loss,div_hlsp_NO3,surf_NO3_loss,div_hlsp_NH4,surf_NH4_loss,&
                        del_soil_DON,del_leaflitter_DON,del_woodlitter_DON,div_DON_loss,del_soil_NH4,del_soil_NO3,del_leaflitter_NH4,&
                        del_leaflitter_NO3,del_woodlitter_NH4,del_woodlitter_NO3,div_NH4_loss,div_NO3_loss)

!xz note: wl soil layer water volumn, mm^3/mm^2, defined by CH ; div, divergent flux or horizontal flow; del is the change along the time dimension


    type(soil_pool),dimension(:),intent(inout)::soil!xz
    type(soil_pool),intent(inout)::leaflitter,woodlitter!xz

!!xz check the unit of flow!!For CH's code, it should be kg/year or kg/dt's unit.!!! I assume here the unit is mm/yr
    real,dimension(:),intent(in)::flow,div,dz,wl !flow (into layer) and wl in units of mm, downward is >0  !!!xz check the unit of dz (should be m in this subroutine), flow (shoul be mm)
    real,intent(in)  :: litterflow  !Flow and divergence for litter layer
    real,intent(in)::dt                       ! time step, s

    real,parameter::dens_h2o=1000.0 !xz

    logical, intent(in) :: tiled ! flag for tiled hydrology

!!!!!!!xz we might need to update this part sine CH and Ben's code do not have N lost from run off ; need to consider to add surf_DON_loss; and div_hlsp_DON
    real, optional, intent(in) :: div_hlsp_DOC(:,:) ! dim(N_C_TYPES, num_l) [kg C/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_DOC_loss(N_C_TYPES) ! [kg C/m^2] loss from top layer to surface runoff
    real, optional, intent(in) :: div_hlsp_DON(:,:) ! dim(N_C_TYPES, num_l) [kg N/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_DON_loss(N_C_TYPES) ! [kg N/m^2] loss from top layer to surface runoff
    real, optional, intent(in) :: div_hlsp_NO3(:),div_hlsp_NH4(:) ! dim(num_l) [kg N/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_NO3_loss,surf_NH4_loss ! [kg N/m^2] loss from top layer to surface runoff
!!!!!!!xz [end]

    !real,intent(out),optional::del_soil_DOC(:,:),div_DOC_loss(:,:),del_leaflitter_DOC(:),del_woodlitter_DOC(:) !xz
    real,intent(out),optional::del_soil_DOC(:,:),del_soil_DON(:,:),div_DOC_loss(:,:),del_leaflitter_DOC(:),del_woodlitter_DOC(:),&
                                                                del_leaflitter_DON(:),del_woodlitter_DON(:),div_DON_loss(:,:),del_soil_NH4(:),del_soil_NO3(:),&
                                del_leaflitter_NH4,del_leaflitter_NO3, del_woodlitter_NH4,del_woodlitter_NO3,&
                                                                div_NH4_loss(:),div_NO3_loss(:) !xz



    !real::DOC(N_C_TYPES,size(soil)+1)!xz
    real::DOC(N_C_TYPES,size(soil)+1), DON(N_C_TYPES,size(soil)+1),NH4_dissolved(size(soil)+1),NO3_dissolved(size(soil)+1)!xz


!    real,dimension(N_C_TYPES,size(soil)+1) :: div_loss!xz
    real,dimension(N_C_TYPES,size(soil)+1) :: div_loss,div_loss_N!xz
    real,dimension(size(soil)+1)           :: div_loss_NO3,div_loss_NH4

    !real::d_DOC(N_C_TYPES,size(soil)+1)!xz
    real::d_DOC(N_C_TYPES,size(soil)+1),d_DON(N_C_TYPES,size(soil)+1),d_NH4(size(soil)+1),d_NO3(size(soil)+1)!xz

    real,dimension(size(soil)+1) :: flow_with_litter, div_with_litter, dz_with_litter ! water flow
    integer::l,ii

    !real::litterThickness,leaflitterTotalC,woodlitterTotalC,DOCbefore(size(soil)+1),leaf_DOC_frac!xz
    real::litterThickness,leaflitterTotalC,woodlitterTotalC,DOCbefore(size(soil)+1),DONbefore(size(soil)+1),leaf_DOC_frac,leaf_DON_frac,&
                        NH4before(size(soil)+1),NO3before(size(soil)+1),leaf_NH4_frac,leaf_NO3_frac

!!!!!!!xz Not in CH's code. need to consider add N here as well.
    real :: surf_DOC_loss_loc(N_C_TYPES), surf_DON_loss_loc(N_C_TYPES), surf_NO3_loss_loc, surf_NH4_loss_loc
    real, parameter :: minwl = 0.1 ! [mm]
!!!!!!!xz [end]

    !For now, use a mininum litter thickness of 5 mm
    call poolTotals(leaflitter, totalCarbon=leaflitterTotalC)
    call poolTotals(woodlitter, totalCarbon=woodlitterTotalC)
    litterThickness=max((leaflitterTotalC+woodlitterTotalC)/litterDensity,5e-3)

!!!!!!!xz note: please make sure the unit of flow is ????
    flow_with_litter(1)=0.0
    flow_with_litter(2:size(flow_with_litter))=flow(1:size(flow_with_litter)-1)  !mm
    flow_with_litter=flow_with_litter/1000 !xz change the div unit from mm to m

    !flow_with_litter(1)=0.0/dens_h2o*dt  !m !CH's code if the unit of flow is kg/m2/yr
    !flow_with_litter(2:size(flow_with_litter))=flow(1:size(flow_with_litter)-1)/dens_h2o*dt   !m


    div_with_litter(1)=0.0
    div_with_litter(2:size(flow_with_litter))=div(:)*dt ! div is in mm/s
    div_with_litter=div_with_litter/1000 !xz change the div unit from mm to m

    !div_with_litter(1)=0.0/dens_h2o*dt!xz!CH's code if the unit of flow is kg/m2/yr
    !div_with_litter(2:size(flow_with_litter))=div(:)/dens_h2o*dt  !m? !xz

    dz_with_litter(1)=litterThickness
    dz_with_litter(2:size(dz_with_litter)) = dz(:) !!xz assume the unit of dz is m

    !flow_with_litter(:)=0.0
    !flow_with_litter(2:)=1e-3


IF(soil_carbon_option == SOILC_CORPSE_N) THEN
!!!!!!!!!!!!!!!!!!xz ADD CH's code for Nitrogen !!!Please Check the unit!!!!! Is the unit of the inputs from the point model the same as the CH's experiment?
    ! Probably should include wood litter in this too
    ! Ammonium should be less soluble than nitrate, probably.  Could use retrieve_dissolved_mineral_N to standardize that --BNS
    if (leaflitter%ammonium + woodlitter%ammonium>0) then
       leaf_NH4_frac = leaflitter%ammonium/(leaflitter%ammonium + woodlitter%ammonium)
    else
       leaf_NH4_frac = 0.5 ! slm: does it make sense?
    endif

    NH4_dissolved(1)=(leaflitter%ammonium + woodlitter%ammonium)*ammonium_solubility  !kg/m2
    leaflitter%ammonium=leaflitter%ammonium-leaflitter%ammonium*ammonium_solubility
    woodlitter%ammonium=woodlitter%ammonium-woodlitter%ammonium*ammonium_solubility
    NH4_dissolved(2:size(soil)+1)=soil(:)%ammonium*ammonium_solubility  !kg/m2
    soil(:)%ammonium=soil(:)%ammonium*(1-ammonium_solubility)

    if (leaflitter%nitrate + woodlitter%nitrate > 0) then
       leaf_NO3_frac = leaflitter%nitrate/(leaflitter%nitrate + woodlitter%nitrate)
    else
       leaf_NO3_frac = 0.0
    endif
    NO3_dissolved(1)=(leaflitter%nitrate + woodlitter%nitrate)*nitrate_solubility   !kg/m2
    leaflitter%nitrate=leaflitter%nitrate-leaflitter%nitrate*nitrate_solubility
    woodlitter%nitrate=woodlitter%nitrate-woodlitter%nitrate*nitrate_solubility
    NO3_dissolved(2:size(soil)+1)=soil(:)%nitrate*nitrate_solubility   !kg/m2
    soil(:)%nitrate=soil(:)%nitrate*(1-nitrate_solubility)

    if(any(NH4_dissolved(:)<-1e-11)) then
                print *,NH4_dissolved(:)
                call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium < 0 (before advection)',FATAL)
        endif

        if(any(NO3_dissolved(:)<-1e-11)) then
                print *,NO3_dissolved(:)
                call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate < 0 (before advection)',FATAL)
        endif

        NH4before=NH4_dissolved(:)
        NO3before=NO3_dissolved(:)

        call tracer_advection(NH4_dissolved(:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_NH4(:),div_loss_NH4(:),wl(:))

        call tracer_advection(NO3_dissolved(:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_NO3(:),div_loss_NO3(:),wl(:))

        !la subroutine tracer_advection mi rida' il valore de la quantita di tracer_dissolved gia' aggiornata con la percolazione che entra ed esce dallo strato di suolo
        !la variazione di massa e' pari a d_NH4 o d_NO3

        if(abs(sum(NH4_dissolved(:))-sum(NH4before)).gt.1e-10) then
                print *,'Ammonium'
                print *,'Before:'
                print *,NH4before
                print *,'After:'
                print *,NH4_dissolved(:)
                print *,'Difference:'
                print *,d_NH4(:)
                print *,'Flow:'
                print *,flow_with_litter
                print *,'Total difference:',sum(NH4_dissolved(:))-sum(NH4before)
                call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium not conserved',FATAL)
        endif
        if(any(NH4_dissolved(:)<0)) call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium < 0 (after advection)',FATAL)

        if(abs(sum(NO3_dissolved(:))-sum(NO3before)).gt.1e-10) then
                print *,'Nitrate'
                print *,'Before:'
                print *,NO3before
                print *,'After:'
                print *,NO3_dissolved(:)
                print *,'Difference:'
                print *,d_NO3(:)
                print *,'Flow:'
                print *,flow_with_litter
                print *,'Total difference:',sum(NO3_dissolved(:))-sum(NO3before)
                call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate not conserved',FATAL)
        endif
        if(any(NO3_dissolved(:)<0)) call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate < 0 (after advection)',FATAL)


    if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
       div_loss_NO3(2:size(soil)+1) = div_hlsp_NO3(:)*dt
       div_loss_NH4(2:size(soil)+1) = div_hlsp_NH4(:)*dt
       if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff -- BNS: include litter layer in this??
          surf_NO3_loss_loc = -NO3_dissolved(2) * flow(1) / wl(1)
          surf_NO3_loss_loc = min(surf_NO3_loss_loc, NO3_dissolved(2))
          surf_NH4_loss_loc = -NH4_dissolved(2) * flow(1) / wl(1)
          surf_NH4_loss_loc = min(surf_NH4_loss_loc, NH4_dissolved(2))
       end if
       div_loss_NO3(2) = min(div_loss_NO3(2), NO3_dissolved(2) - surf_NO3_loss_loc)
       div_loss_NH4(2) = min(div_loss_NH4(2), NH4_dissolved(2) - surf_NH4_loss_loc)
       do l=3,size(soil)+1
          div_loss_NO3(l) = min(div_loss_NO3(l), NO3_dissolved(l))
          div_loss_NH4(l) = min(div_loss_NH4(l), NH4_dissolved(l))
       end do
       ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
       ! that will be effectively rectified by subtracting from the flux to stream. In rare
       ! situations, that could lead to a negative stream DOC flux.

       NH4_dissolved(2)=NH4_dissolved(2)-surf_NH4_loss_loc
       NO3_dissolved(2)=NO3_dissolved(2)-surf_NO3_loss_loc

    end if

        NH4_dissolved(:)=NH4_dissolved(:)-div_loss_NH4(:)  !aggiorno la quantita' di ammonio in soluzione nel suolo togliendo la parte che e' uscita con il flusso laterale

        NO3_dissolved(:)=NO3_dissolved(:)-div_loss_NO3(:)


	leaflitter%ammonium=leaflitter%ammonium + NH4_dissolved(1)*leaf_NH4_frac
    woodlitter%ammonium=woodlitter%ammonium + NH4_dissolved(1)*(1.0-leaf_NH4_frac)

	soil(:)%ammonium=soil(:)%ammonium + NH4_dissolved(2:size(soil)+1)

	leaflitter%nitrate=leaflitter%nitrate + NO3_dissolved(1)*leaf_NO3_frac
    woodlitter%nitrate=woodlitter%nitrate + NO3_dissolved(1)*(1.0-leaf_NO3_frac)
	soil(:)%nitrate=soil(:)%nitrate + NO3_dissolved(2:size(soil)+1)

        if(present(del_soil_NH4)) del_soil_NH4(:)=d_NH4(2:size(soil)+1)  !variazione con la percolazione del contenuto di NH4 nel suolo
        if(present(del_soil_NO3)) del_soil_NO3(:)=d_NO3(2:size(soil)+1)

        if(present(del_leaflitter_NH4)) del_leaflitter_NH4=d_NH4(1)*leaf_NH4_frac
        if(present(del_leaflitter_NO3)) del_leaflitter_NO3=d_NO3(1)*leaf_NO3_frac
    if(present(del_woodlitter_NH4)) del_woodlitter_NH4=d_NH4(1)*(1.0-leaf_NH4_frac)
        if(present(del_woodlitter_NO3)) del_woodlitter_NO3=d_NO3(1)*(1.0-leaf_NO3_frac)


        if(present(div_NH4_loss)) div_NH4_loss(:)=div_loss_NH4(2:size(soil)+1)
        if(present(div_NO3_loss)) div_NO3_loss(:)=div_loss_NO3(2:size(soil)+1)

!!!!!!!!!!!!!!!!!!xz [End] CH's code for Nitrogen
ELSE  ! End of code if SOILC_CORPSE_N
    if(present(surf_NO3_loss)) surf_NO3_loss=0.0
    if(present(surf_NH4_loss)) surf_NH4_loss=0.0
    if(present(del_soil_NH4)) del_soil_NH4=0.0
    if(present(del_soil_NO3)) del_soil_NO3=0.0
    if(present(del_leaflitter_NH4)) del_leaflitter_NH4=0.0
    if(present(del_leaflitter_NO3)) del_leaflitter_NO3=0.0
    if(present(del_woodlitter_NH4)) del_woodlitter_NH4=0.0
    if(present(del_woodlitter_NO3)) del_woodlitter_NO3=0.0
    if(present(div_NH4_loss)) div_NH4_loss=0.0
    if(present(div_NO3_loss)) div_NO3_loss=0.0


ENDIF

  call dissolve_carbon(leaflitter,wl(1)/(dens_h2o*dz(1))) ! Doesn't take porosity into account
  call dissolve_carbon(woodlitter,wl(1)/(dens_h2o*dz(1)))
  do ii=1, size(soil)
    call dissolve_carbon(soil(ii),wl(ii)/(dens_h2o*dz(ii)))
  enddo

    surf_DOC_loss_loc(:) = 0.0
    surf_DON_loss_loc(:) = 0.0
    do ii=1,N_C_TYPES
       DOC(ii,1)=leaflitter%dissolved_carbon(ii)+woodlitter%dissolved_carbon(ii)


       if(DOC(ii,1)>0) then
           leaf_DOC_frac=leaflitter%dissolved_carbon(ii)/DOC(ii,1)
       else
           leaf_DOC_frac=0.0
       endif


       DOC(ii,2:size(soil)+1)=soil(:)%dissolved_carbon(ii)


       if(any(DOC(ii,:)<0)) then
           print *,'Carbon flavor',ii
           print *,DOC(ii,:)
           call error_mesg('tracer_leaching_with_litter','Dissolved carbon < 0 (before advection)',FATAL)
       endif

       DOCbefore=DOC(ii,:)


       if (is_watch_point()) then
          __DEBUG1__(DOCbefore)
       endif

       !call tracer_advection(DOC(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,wl,d_DOC(ii,:),div_loss(ii,:))!xz
       call tracer_advection(DOC(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_DOC(ii,:),div_loss(ii,:),wl(:))!xz

       if (is_watch_point()) then
          __DEBUG1__(DOC(ii,:))
       endif

       if(abs(sum(DOC(ii,:))-sum(DOCbefore)).gt.1e-10) then
           print *,'Flavor:',ii
           print *,'Before:'
           print *,DOCbefore
           print *,'After:'
           print *,DOC(ii,:)
           print *,'Difference:'
           print *,d_DOC(ii,:)
           print *,'Flow:'
           print *,flow_with_litter
           print *,'Total difference:',sum(DOC(ii,:))-sum(DOCbefore)
           call error_mesg('tracer_leaching_with_litter','Dissolved carbon not conserved',FATAL)
       endif
       if(any(DOC(ii,:)<-1e-11)) call error_mesg('tracer_leaching_with_litter','Dissolved carbon < 0 (after advection)',FATAL)

       if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
          div_loss(ii,2:size(soil)+1) = div_hlsp_DOC(ii,:)*dt
          if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff
             surf_DOC_loss_loc(ii) = -DOC(ii, 2) * flow(1) / wl(1)
             surf_DOC_loss_loc(ii) = min(surf_DOC_loss_loc(ii), DOC(ii,2))
          end if
          div_loss(ii,2) = min(div_loss(ii,2), DOC(ii,2) - surf_DOC_loss_loc(ii))
          do l=3,size(soil)+1
             div_loss(ii,l) = min(div_loss(ii,l), DOC(ii,l))
          end do
          ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
          ! that will be effectively rectified by subtracting from the flux to stream. In rare
          ! situations, that could lead to a negative stream DOC flux.
       end if
       DOC(ii,:)=DOC(ii,:)-div_loss(ii,:)
       DOC(ii,2)=DOC(ii,2)-surf_DOC_loss_loc(ii)!!xz This line does not exist in CH's code ; consider to add similar line to Nitrogen part
       ! Xin says this line was a mistake

       leaflitter%dissolved_carbon(ii)=DOC(ii,1)*leaf_DOC_frac
       woodlitter%dissolved_carbon(ii)=DOC(ii,1)*(1.0-leaf_DOC_frac)
       soil(:)%dissolved_carbon(ii)=DOC(ii,2:size(soil)+1)

       if(present(del_soil_DOC)) del_soil_DOC(ii,:)=d_DOC(ii,2:size(soil)+1)
       if(present(del_leaflitter_DOC)) del_leaflitter_DOC(ii)=d_DOC(ii,1)*leaf_DOC_frac
       if(present(del_woodlitter_DOC)) del_woodlitter_DOC(ii)=d_DOC(ii,1)*(1.0-leaf_DOC_frac)

       if(present(div_DOC_loss)) div_DOC_loss(ii,:)=div_loss(ii,2:size(soil)+1)
       if(present(surf_DOC_loss)) surf_DOC_loss(ii) = surf_DOC_loss_loc(ii)!!xz This line does not exist in CH's code

!!!!!xz Nitrogen

    IF(soil_carbon_option == SOILC_CORPSE_N) THEN

        DON(ii,1)=leaflitter%dissolved_nitrogen(ii)+woodlitter%dissolved_nitrogen(ii)!xz
         if(DON(ii,1)>0) then
             leaf_DON_frac=leaflitter%dissolved_nitrogen(ii)/DON(ii,1)
         else
             leaf_DON_frac=0.0
         endif !xz
        DON(ii,2:size(soil)+1)=soil(:)%dissolved_nitrogen(ii)!xz
        if(any(DON(ii,:)<-1e-11)) then
             print *,'Nitrogen flavor',ii
             print *,DON(ii,:)
             call error_mesg('tracer_leaching_with_litter','Dissolved nitrogen < 0 (before advection)',FATAL)
        endif!xz
        DONbefore=DON(ii,:)!xz

       call tracer_advection(DON(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_DON(ii,:),div_loss_N(ii,:),wl(:))
                if(abs(sum(DON(ii,:))-sum(DONbefore)).gt.1e-10) then
                        print *,'Flavor:',ii
                        print *,'Before:'
                        print *,DONbefore
                        print *,'After:'
                        print *,DON(ii,:)
                        print *,'Difference:'
                        print *,d_DON(ii,:)
                        print *,'Flow:'
                        print *,flow_with_litter
                        print *,'Total difference:',sum(DON(ii,:))-sum(DONbefore)
                        call error_mesg('nitrogen_leaching_with_litter','Dissolved nitrogen not conserved',FATAL)
                endif
                if(any(DON(ii,:)<-1e-11)) call error_mesg('nitrogen_leaching_with_litter','Dissolved nitrogen < 0 (after advection)',FATAL)



        if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
           div_loss_N(ii,2:size(soil)+1) = div_hlsp_DON(ii,:)*dt
           if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff
              surf_DON_loss_loc(ii) = -DON(ii, 2) * flow(1) / wl(1)
              surf_DON_loss_loc(ii) = min(surf_DON_loss_loc(ii), DON(ii,2))
           end if
           div_loss_N(ii,2) = min(div_loss_N(ii,2), DON(ii,2) - surf_DON_loss_loc(ii))
           do l=3,size(soil)+1
              div_loss_N(ii,l) = min(div_loss_N(ii,l), DON(ii,l))
           end do
           ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
           ! that will be effectively rectified by subtracting from the flux to stream. In rare
           ! situations, that could lead to a negative stream DOC flux.
        end if

        DON(ii,2)=DON(ii,2)-surf_DON_loss_loc(ii)!!xz This line does not exist in CH's code ; consider to add similar line to Nitrogen part
       ! Xin says this line was a mistake




                DON(ii,:)=DON(ii,:)-div_loss_N(ii,:)

                leaflitter%dissolved_nitrogen(ii)=DON(ii,1)*leaf_DON_frac
                woodlitter%dissolved_nitrogen(ii)=DON(ii,1)*(1.0-leaf_DON_frac)
                soil(:)%dissolved_nitrogen(ii)=DON(ii,2:size(soil)+1)

                if(present(del_soil_DON)) del_soil_DON(ii,:)=d_DON(ii,2:size(soil)+1)
                if(present(del_leaflitter_DON)) del_leaflitter_DON(ii)=d_DON(ii,1)*leaf_DON_frac
                if(present(del_woodlitter_DON)) del_woodlitter_DON(ii)=d_DON(ii,1)*(1.0-leaf_DON_frac)

                if(present(div_DON_loss)) div_DON_loss(ii,:)=div_loss_N(ii,2:size(soil)+1)

    ELSE

                if(present(del_soil_DON)) del_soil_DON(ii,:)=0.0
                if(present(del_leaflitter_DON)) del_leaflitter_DON(ii)=0.0
                if(present(del_woodlitter_DON)) del_woodlitter_DON(ii)=0.0

                if(present(div_DON_loss)) div_DON_loss(ii,:)=0.0
    ENDIF

!!!!xz Nitrogen [end]
    enddo

    call deposit_dissolved_C(leaflitter)
    call deposit_dissolved_C(woodlitter)
    do ii=1, size(soil)
      call deposit_dissolved_C(soil(ii))
    enddo


end subroutine tracer_leaching_with_litter


subroutine retrieve_DOC(soil, DOC, num_l)

   type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
   integer, intent(in)  :: num_l ! number of soil layers
   real, intent(out)    :: DOC(N_C_TYPES, num_l) ! [kg C/m^2] dissolved organic carbon
   integer :: l

   do l=1,num_l
      DOC(1:N_C_TYPES,l)=soil(l)%dissolved_carbon(1:N_C_TYPES)
   end do

end subroutine retrieve_DOC

subroutine retrieve_DON(soil, DON, num_l)

    type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
    integer, intent(in)  :: num_l ! number of soil layers
    real, intent(out)    :: DON(N_C_TYPES, num_l) ! [kg C/m^2] dissolved organic nitrogen
    integer :: l

    if(soil_carbon_option == SOILC_CORPSE_N) then
        do l=1,num_l
            DON(1:N_C_TYPES,l)=soil(l)%dissolved_nitrogen(1:N_C_TYPES)
        end do
    else
        DON=0.0
    endif
end subroutine retrieve_DON


subroutine retrieve_dissolved_mineral_N(soil,nitrate,ammonium,num_l)
    ! Maybe this should include some solubility parameter that differs between nitrate and ammonium
    type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
    integer, intent(in)  :: num_l ! number of soil layers
    real, intent(out)    :: nitrate(num_l),ammonium(num_l) ! [kg N/m^2] dissolved nitrate and ammonium
    integer :: l

    if(soil_carbon_option == SOILC_CORPSE_N) then
        do l=1,num_l
            nitrate(l)=soil(l)%nitrate
            ammonium(l)=soil(l)%ammonium
        end do

    else
        nitrate=0.0
        ammonium=0.0
    endif

end subroutine retrieve_dissolved_mineral_N



function Knitrif(T)
    real,intent(in)::T
    real,parameter::Tref=293.15   !Tref is in kelvin not celcus
    real::alpha,Knitrif

    alpha=Knitr_ref/exp(-Ea_nitrif/(Rugas*Tref))
    Knitrif=alpha*exp(-Ea_nitrif/(Rugas*T))
end function Knitrif

function Kdenitr(T)
    real,intent(in)::T
    real,parameter::Tref=293.15   !LA TEMPERATURA  IN KELVIN ED EQUIVALE A 20C
    real::alpha,Kdenitr

    alpha=Kdenitr_ref/exp(-Ea_denitr/(Rugas*Tref))
    Kdenitr=alpha*exp(-Ea_denitr/(Rugas*T))
end function Kdenitr


function V_NH4(T)
    real,intent(in)::T
    real,parameter::Tref=293.15   !LA TEMPERATURA  IN KELVIN ED EQUIVALE A 20C
    real::alpha,V_NH4

    alpha=V_NH4_ref/exp(-Ea_NH4/(Rugas*Tref))
    V_NH4=alpha*exp(-Ea_NH4/(Rugas*T))

end function V_NH4

function V_NO3(T)
    real,intent(in)::T
    real,parameter::Tref=293.15   !Tref is in kelvin not celcus
    real::alpha,V_NO3

    alpha=V_NO3_ref/exp(-Ea_NO3/(Rugas*Tref))
    V_NO3=alpha*exp(-Ea_NO3/(Rugas*T))

end function V_NO3



#ifndef STANDALONE_SOIL_CARBON
subroutine adjust_pool_ncohorts(pool)
    type(soil_pool),intent(inout) :: pool

    !Remove cohorts if size is too large
    if (pool%n_cohorts.gt.soilMaxCohorts) call cull_cohorts(pool)

    !Add empty cohorts until size is correct
    do while (pool%n_cohorts.lt.soilMaxCohorts)
        call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    enddo
end subroutine

#else

subroutine error_mesg(routine,message,level)
    character(len=*),intent(in)::routine,message
    integer::level

    if(level.eq.FATAL) then
    print *,'Error in routine ',routine,': ',message
    stop
    else
    print *,'Note from routine ',routine,': ',message
    endif
end subroutine

!Copied from soil_numerics (by sergey malyshev)
! ============================================================================
! given values of the triadiagonal matrix coefficients, computes a solution
subroutine tridiag(a,b,c,r,u)
  real, intent(in)  :: a(:),b(:),c(:),r(:)
  real, intent(out) :: u(:)

  integer :: j
  real :: bet, gam(size(a))

  ! check that the sizes are the same
  if(size(a)/=size(b).or.size(a)/=size(c).or.size(a)/=size(r)) &
       call error_mesg('tridiag','sizes of input arrays are not equal',FATAL)
  if(size(u)<size(a)) &
       call error_mesg('tridiag','size of the result is insufficient',FATAL)
  ! check that a(1)==0 and c(N)==0
  if(a(1)/=0.or.c(size(a))/=0) &
       call error_mesg('tridiag','a(1) and c(N) must be equal to 0',FATAL)
  ! decomposition and forward substitution
  bet = b(1)
  u(1) = r(1)/bet
  do j = 2,size(a)
     gam(j) = c(j-1)/bet
     bet = b(j)-a(j)*gam(j)
     if(bet==0) &
          call error_mesg('tridiag','system is ill-defined',FATAL)
     u(j) = (r(j)-a(j)*u(j-1))/bet
  enddo
  ! backward substitution
  do j = size(a)-1,1,-1
     u(j) = u(j)-gam(j+1)*u(j+1)
  enddo
end subroutine tridiag
#endif

! pgi: does not have bult-in isNaN function
! gfortran: versions <5 do not appear to support ieee_arithmetic module

! note that there is a danger that the compilr optimizes the comparison away
! but I don't see how
logical elemental function is_nan(x)
   real, intent(in) :: x
   is_nan = (x/=x)
end function is_nan

end module soil_carbon_mod
